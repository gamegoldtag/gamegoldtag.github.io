<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="tokio vs async-std, blocking in async, task spawning, channel patterns, timeout handling">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-17.html">
  <title>Rust async/await 삽질 정리 — tokio 런타임에서 겪은 문제들 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Rust async/await 삽질 정리 — tokio 런타임에서 겪은 문제들",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-05-13",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-17.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Rust</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>Rust async/await 삽질 정리 — tokio 런타임에서 겪은 문제들</h1>
      <p class="meta">게시일: 2025년 5월 13일 · 16분 읽기</p>

<p>async fn 안에서 std::thread::sleep 호출해서 런타임 멈춘 거 디버깅에 반나절 걸렸다.</p>

<h3>문제 1: Blocking in Async Context</h3>

<p>나쁜 코드:</p>

<pre><code>async fn process_audio(path: &amp;str) -> Result&lt;()&gt; {
    let file = std::fs::read(path)?;  // ← Blocking I/O!

    // 이 시점에서 runtime 스레드가 blocked됨
    // 다른 async 작업들이 진행되지 않음

    let processed = decode(&amp;file).await?;
    Ok(())
}
</code></pre>

<p>문제: std::fs::read는 blocking이다. async fn 안에서 blocking 호출이 있으면, 전체 runtime 스레드가 멈춘다.</p>

<p>좋은 코드:</p>

<pre><code>async fn process_audio(path: &amp;str) -> Result&lt;()&gt; {
    let file = tokio::fs::read(path).await?;  // ← Non-blocking!

    let processed = decode(&amp;file).await?;
    Ok(())
}

// 또는 blocking 작업을 별도 스레드에서
async fn process_audio_alt(path: &amp;str) -> Result&lt;()&gt; {
    let path = path.to_string();

    let file = tokio::task::block_in_place(|| {
        std::fs::read(&amp;path)  // ← 전용 스레드에서 실행
    })?;

    let processed = decode(&amp;file).await?;
    Ok(())
}
</code></pre>

<h3>문제 2: std::thread::sleep in async</h3>

<p>실제 사례:</p>

<pre><code>async fn connect_with_retry(server: &amp;str) -> Result&lt;()&gt; {
    for attempt in 1..=3 {
        match connect(server).await {
            Ok(_) => return Ok(()),
            Err(_) if attempt &lt; 3 =&gt; {
                std::thread::sleep(Duration::from_secs(1));  // ❌ 재앙!
            }
            Err(e) => return Err(e),
        }
    }
    Ok(())
}
</code></pre>

<p>이 코드 실행 시:</p>

<blockquote>
<p>- 첫 번째 연결 실패<br>
- std::thread::sleep(1초) → runtime 전체 blocked<br>
- 다른 async 작업들도 모두 1초 대기<br>
- 사용자: "앱이 멈춤"</p>
</blockquote>

<p>해결:</p>

<pre><code>async fn connect_with_retry(server: &amp;str) -> Result&lt;()&gt; {
    for attempt in 1..=3 {
        match connect(server).await {
            Ok(_) => return Ok(()),
            Err(_) if attempt &lt; 3 =&gt; {
                tokio::time::sleep(Duration::from_secs(1)).await;  // ✅ OK
            }
            Err(e) => return Err(e),
        }
    }
    Ok(())
}
</code></pre>

<p>tokio::time::sleep은 non-blocking이다. 다른 작업은 계속 진행된다.</p>

<h3>문제 3: unbounded channel 남용으로 메모리 폭증</h3>

<p>이벤트를 빠르게 밀어 넣는 producer와 느린 consumer를 같이 두면, <code>unbounded_channel</code>은 결국 메모리를 먹고 장애를 만든다.</p>

<p>권장 패턴:</p>

<pre><code>use tokio::sync::mpsc;
use tokio::time::{timeout, Duration};

let (tx, mut rx) = mpsc::channel::&lt;Job&gt;(256); // bounded channel

// producer
if let Err(_e) = timeout(Duration::from_millis(200), tx.send(job)).await {
    // 큐가 가득 찬 상태가 오래 지속되면 drop / retry 정책 선택
}
</code></pre>

<p>bounded channel을 쓰면 시스템이 감당 가능한 처리량을 넘길 때 바로 신호가 오고, 백프레셔 정책을 코드로 명시할 수 있다.</p>

<h3>문제 4: timeout 없이 외부 I/O await</h3>

<p>네트워크, DB, 외부 API는 반드시 timeout을 걸어야 한다. timeout이 없으면 특정 요청이 무기한 대기하고, 트래픽이 몰릴 때 워커가 잠식된다.</p>

<pre><code>use tokio::time::{timeout, Duration};

let resp = timeout(Duration::from_secs(3), client.get(url).send()).await
    .map_err(|_| anyhow!("request timeout"))??;
</code></pre>

<p>실무에서는 "평균 지연"보다 "최악 지연"이 장애를 만든다. timeout은 성능 최적화가 아니라 안정성 장치다.</p>

<h3>운영 체크리스트</h3>

<ul>
<li>async 함수 내부에서 <code>std::fs</code>, <code>std::thread::sleep</code> 사용 금지</li>
<li>CPU-heavy 작업은 <code>spawn_blocking</code> 또는 전용 워커로 분리</li>
<li>채널은 기본적으로 bounded, 크기는 근거(처리량/지연) 기반으로 설정</li>
<li>외부 I/O는 timeout + retry + circuit-breaker 정책 같이 설계</li>
<li>종료 시그널 처리(<code>ctrl_c</code>)와 graceful shutdown 경로 검증</li>
</ul>

<h3>결론</h3>

<p>async/await는 생산성을 크게 올려주지만, "block 금지 / backpressure / timeout" 세 가지를 지키지 않으면 장애를 만든다. 위 규칙을 기본값으로 잡으면 tokio 기반 서비스의 안정성이 눈에 띄게 올라간다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>실무 개발자입니다. 현장에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-04.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체</span>
        </a>
        <a class="related-item" href="/posts/post-58.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 크로스 컴파일 — Windows/macOS/Linux 한 번에 빌드하기</span>
        </a>
        <a class="related-item" href="/posts/post-77.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>
