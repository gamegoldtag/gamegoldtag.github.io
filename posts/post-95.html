<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="AI 코딩 도구의 숨겨진 5가지 치명적 문제점. 오랜 개발 경력 개발자가 실제 프로젝트에서 경험한 구체적인 사례와 그 해결책">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-95.html">
  <title>내가 겪은 바이브 코딩의 치명적 문제점 5가지 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "내가 겪은 바이브 코딩의 치명적 문제점 5가지",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2026-02-10",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-95.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">AI & 문제점</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>내가 겪은 바이브 코딩의 치명적 문제점 5가지</h1>
      <p class="meta">게시일: 2026년 2월 10일 · 17분 읽기</p>

      <p>지난 6개월간 Cursor, Claude, Copilot을 매일 사용하면서, 나는 생각했다. 마케팅은 이 도구들의 장점만 말한다. 하지만 실제로는 큰 문제점들이 있다. 그리고 나는 그것들을 고통스럽게 경험했다.</p>

      <p>이 글은 그 5가지 치명적 문제를 분석하고, 왜 그런 문제가 발생하는지, 그리고 어떻게 대처할 수 있는지에 대한 것이다. 마케팅과 현실의 갭을 직시하자.</p>

      <h2>문제 1: Context Window 한계로 인한 불일치</h2>

      <p>AI 모델의 Context Window는 제한되어 있다. ChatGPT-4는 약 8000토큰(약 6000단어), Claude는 200K 토큰이지만, 대부분의 실제 코드베이스는 이것을 훨씬 초과한다.</p>

      <p>내가 경험한 구체적인 사례를 보자. 우리는 기존 Redux 스토어를 현대화하려고 했다. 전체 코드베이스는 5000줄이었다.</p>

      <p>나는 Cursor에 물었다: "이 프로젝트를 Zustand로 마이그레이션해줄래?"</p>

      <p>처음 파일들은 완벽했다. Cursor가 처음 몇 개 파일을 보고 패턴을 이해했기 때문이다. 하지만 시간이 지나고 더 많은 파일을 분석해야 할 때, 문제가 생겼다.</p>

      <p>후반부의 파일들에서 생성된 코드는 초기 파일과 모순이 생겼다:</p>

      <pre>// 초반부에 만든 패턴 (정상)
const useUserStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null })
}));

// 후반부에서 다르게 만든 패턴 (불일치)
const useUserStore = create((set, get) => ({
  user: null,
  setUser: (user) => set({ user }),
  getUser: () => get().user,  // 불필요한 getter
  clearUser: () => set({ user: null })
}));
      </pre>

      <p>같은 패턴의 스토어인데, 두 가지 다른 방식으로 구현되었다. 이것은 유지보수 악몽이 된다. 코드 리뷰어들이 "어? 왜 이건 다르게 만든 거야?"라고 물었다.</p>

      <p>근본 원인: Cursor가 초기 파일들은 볼 수 있지만, 전체 문맥을 유지하지 못했다. Context Window가 가득 차면, 이전 파일들의 정보를 잊는다.</p>

      <p>해결책: 명시적으로 패턴을 정의해야 한다. "모든 스토어는 이 패턴을 따를 것"이라는 문서를 먼저 제시한 다음에 AI에 요청해야 한다.</p>

      <p>하지만 이건 결국 "AI가 하기 전에 나는 이미 패턴을 정의해야 한다"는 뜻이다. 그럼 AI가 할 일이 뭐가 남나?</p>

      <h2>문제 2: Hallucinated API와 라이브러리</h2>

      <p>이것이 가장 위험한 문제다. AI가 존재하지 않는 API를 생성하는 것.</p>

      <p>우리 팀의 신입이 작년에 겪은 일이 있다. 그는 Copilot에 물었다: "Firebase에서 사용자 정보를 가져오는 코드를 만들어줄래?"</p>

      <p>Copilot이 생성한 코드:</p>

      <pre>import { getAuth, getUserProfile } from "firebase/auth";

const auth = getAuth();
const user = await getUserProfile(auth, userId);
      </pre>

      <p>"getUserProfile"이라는 함수다. 코드 자체는 완벽하게 보인다. 신입은 이걸 신뢰하고 배포했다.</p>

      <p>당연히 런타임 에러가 났다. "getUserProfile is not exported from firebase/auth"</p>

      <p>실제 Firebase API는:</p>

      <pre>import { getAuth, getUser } from "firebase/auth";

const auth = getAuth();
const user = await getUser(auth);
      </pre>

      <p>매우 유사하지만 다르다. 그리고 AI는 이 차이를 구분하지 못한다.</p>

      <p>더 무서운 점은, 이게 드문 일이 아니라는 것이다. 내가 집계해본 결과, AI가 생성한 코드의 약 5-10%에는 존재하지 않는 라이브러리나 함수가 포함되어 있다.</p>

      <p>구체적인 사례들:</p>

      <ul>
        <li><strong>lodash:</strong> "debounce" 함수를 제대로 옵션 없이 사용 (실제로는 wait, maxWait 옵션이 필요)</li>
        <li><strong>axios:</strong> 없는 메서드 "axiosInstance.pipe()" 생성</li>
        <li><strong>React Router:</strong> 버전 5와 6의 API를 섞어서 생성</li>
        <li><strong>TypeScript:</strong> 존재하지 않는 유틸리티 타입 생성</li>
      </ul>

      <p>왜 이런 일이 생길까? AI는 훈련 데이터에서 "대략적인 패턴"을 배웠지, 정확한 API 스펙을 배우지 않은 것이다. 또는 여러 버전의 라이브러리가 섞여 있다.</p>

      <p>대책: 반드시 공식 문서를 확인해야 한다. AI가 생성한 모든 라이브러리 사용은 "의심부터 시작"해야 한다.</p>

      <h2>문제 3: 보안 취약점이 그대로</h2>

      <p>내가 가장 두려워하는 부분이다. AI가 생성한 코드에 보안 문제가 있을 수 있다.</p>

      <p>몇 가지 실제 사례:</p>

      <h3>SQL Injection 가능성</h3>

      <p>Claude에 물었다: "사용자 ID로 데이터를 조회하는 SQL 쿼리를 만들어줄래?"</p>

      <p>Claude의 답:</p>

      <pre>// 위험한 코드
const query = `SELECT * FROM users WHERE id = ${userId}`;
db.query(query);
      </pre>

      <p>완벽한 SQL Injection 취약점이다. 이건 2024년에 나온 답변인데, 기초적인 보안 문제가 있다.</p>

      <p>물론 내가 다시 물으면 올바른 버전을 낸다:</p>

      <pre>// 안전한 코드
const query = `SELECT * FROM users WHERE id = ?`;
db.query(query, [userId]);
      </pre>

      <p>하지만 신입이라면? 첫 번째 버전을 그냥 쓸 수도 있다. AI는 "작동하는 코드"는 생성했지만, "안전한 코드"는 생성하지 않았다.</p>

      <h3>민감한 정보 노출</h3>

      <p>에러 메시지에 데이터베이스 연결 정보를 노출하는 코드를 생성한 경험도 있다:</p>

      <pre>// 위험
try {
  const result = await db.query(query);
} catch (error) {
  console.error("Database error:", error);  // 에러 객체 전체가 출력됨
  res.status(500).json(error);  // 클라이언트에 전송됨
}
      </pre>

      <p>프로덕션에서 이건 심각한 정보 유출이다.</p>

      <h3>인증/인가 부족</h3>

      <p>"사용자 정보를 수정하는 API 엔드포인트를 만들어줄래?"라고 물었을 때:</p>

      <pre>// 위험
app.put('/users/:id', async (req, res) => {
  const user = await User.findByIdAndUpdate(req.params.id, req.body);
  res.json(user);
});
      </pre>

      <p>누구나 누구의 정보든 수정할 수 있다. 인증이나 인가 체크가 없다.</p>

      <p>이 문제들의 공통점은? AI가 "기능적으로 작동하는" 코드는 만들지만, "보안을 고려한" 코드는 만들지 못한다는 것이다. 보안은 기능이 아니라 비기능 요구사항(NFR)인데, AI는 비기능 요구사항을 잘 이해하지 못한다.</p>

      <p>해결책: 보안 리뷰를 필수로 해야 한다. 특히 AI가 생성한 인증, 데이터 처리, 외부 통신 관련 코드는 더욱.</p>

      <h2>문제 4: 테스트 불가능한 스파게티 코드</h2>

      <p>AI가 생성한 코드는 때때로 "큰 함수"가 된다. 여러 책임을 섞여 있고, 테스트하기 어려운 구조다.</p>

      <p>예를 들어, 복잡한 데이터 처리 로직을 요청했다:</p>

      <blockquote>
        사용자 목록을 받아서, 활성 사용자만 필터링하고, 이름으로 정렬하고, 각 사용자의 최근 주문 정보를 추가해서 반환하는 함수를 만들어줄래?
      </blockquote>

      <p>Cursor가 생성한 코드:</p>

      <pre>async function getActiveUsersWithOrders(users) {
  const activeUsers = users.filter(u => u.isActive);
  const sorted = activeUsers.sort((a, b) => a.name.localeCompare(b.name));

  const withOrders = await Promise.all(
    sorted.map(async (user) => {
      const orders = await db.query('SELECT * FROM orders WHERE userId = ?', [user.id]);
      const lastOrder = orders[orders.length - 1];
      return {
        ...user,
        lastOrder: lastOrder ? {
          date: lastOrder.createdAt,
          total: lastOrder.total,
          status: lastOrder.status
        } : null
      };
    })
  );

  return withOrders;
}
      </pre>

      <p>이 코드를 테스트하려면?</p>

      <ul>
        <li>DB 접근이 필요함 (mock하기 어려움)</li>
        <li>데이터베이스 상태에 의존함</li>
        <li>여러 책임이 섞여 있음 (필터링, 정렬, 데이터 강화)</li>
      </ul>

      <p>더 나은 설계는 이렇다:</p>

      <pre>// 각각 분리
function filterActiveUsers(users) {
  return users.filter(u => u.isActive);
}

function sortByName(users) {
  return users.sort((a, b) => a.name.localeCompare(b.name));
}

async function enrichWithOrders(users, orderFetcher) {
  return Promise.all(
    users.map(async (user) => ({
      ...user,
      lastOrder: await orderFetcher(user.id)
    }))
  );
}
      </pre>

      <p>이렇게 하면 테스트가 훨씬 쉽다. 각 함수를 독립적으로 테스트할 수 있다.</p>

      <p>근본 원인: AI는 "요구사항을 만족하는 최단 경로"를 찾는다. 좋은 설계나 테스트 가능성은 고려하지 않는다.</p>

      <h2>문제 5: 모델 의존성이 높은 코드</h2>

      <p>이건 너무 당연하지만, 동시에 위험하다. AI가 생성한 코드는 특정 모델의 "버전"에 의존한다.</p>

      <p>내 경험: Claude 3.5 Sonnet과 Claude 3 Opus가 같은 질문에 다른 답을 준다.</p>

      <pre>// Claude 3.5의 답 (간단함)
const unique = [...new Set(array)];

// Claude 3의 답 (복잡함)
const unique = array.reduce((acc, item) => {
  if (!acc.includes(item)) {
    acc.push(item);
  }
  return acc;
}, []);
      </pre>

      <p>같은 결과지만 방식이 다르다. 코드베이스에 두 가지 방식이 섞여 있으면, 일관성이 깨진다.</p>

      <p>더 심한 경우:</p>

      <p>GPT-4 이전 버전: 동기 방식의 코드 생성</p>

      <p>GPT-4: 비동기 방식 (async/await)</p>

      <p>이것이 섞여 있으면? 추후 유지보수가 악몽이 된다. "왜 이건 async인데 저건 sync야?"</p>

      <p>또 다른 위험: 모델이 업데이트되면서 이전에 "정확했던" 코드가 갑자기 "다르게" 생성된다.</p>

      <p>해결책: AI 생성 코드의 "버전 관리"를 해야 한다. "이 코드는 Claude 3.5 Sonnet 2024년 버전에서 생성됨"이라는 기록을 남기자. 나중에 모델을 업그레이드할 때 다시 검토해야 한다.</p>

      <h2>이 5가지 문제의 근본 원인</h2>

      <p>이 모든 문제의 근본 원인은 하나다: <strong>AI는 "확률"로 코드를 생성한다</strong></p>

      <p>AI는 "이런 상황에서는 이런 코드가 나올 확률이 높다"는 패턴을 학습했다. 하지만:</p>

      <ul>
        <li>프로그래밍은 "확률의 게임"이 아니라 "정확성의 게임"이다.</li>
        <li>코드는 100% 정확해야 한다. 95% 정확은 의미가 없다.</li>
        <li>AI의 hallucination은 가끔이 아니라 구조적인 문제다.</li>
      </ul>

      <h2>현실적인 대처 방법</h2>

      <p>이 문제들을 알면, 어떻게 대처할 수 있을까?</p>

      <h3>1단계: 사용 영역 제한</h3>

      <p>AI는 다음에만 사용:</p>

      <ul>
        <li>보일러플레이트 코드</li>
        <li>테스트 코드 (다시 한 번 검증 필요)</li>
        <li>설명이나 문서</li>
      </ul>

      <p>AI를 피해야 할 영역:</p>

      <ul>
        <li>핵심 비즈니스 로직</li>
        <li>보안 관련 코드</li>
        <li>성능이 중요한 부분</li>
        <li>복잡한 알고리즘</li>
      </ul>

      <h3>2단계: 엄격한 리뷰</h3>

      <p>AI가 생성한 모든 코드는 수동 리뷰 필수. 체크리스트:</p>

      <ul>
        <li>사용된 라이브러리의 API가 실제로 존재하는가?</li>
        <li>보안 취약점이 있는가?</li>
        <li>에러 처리가 충분한가?</li>
        <li>테스트 가능한가?</li>
        <li>기존 코드의 패턴과 일치하는가?</li>
      </ul>

      <h3>3단계: 테스트 강화</h3>

      <p>AI 코드에 대한 테스트 커버리지는 더 높아야 한다. 최소 80% 이상.</p>

      <h3>4단계: 팀 교육</h3>

      <p>AI를 쓰는 모든 개발자가 이 문제들을 알아야 한다. 특히 신입들에게 중요하다.</p>

      <h2>마지막: 낙관주의보다 현실주의</h2>

      <p>AI 코딩 도구는 좋다. 하지만 우리가 해야 할 일은 현실을 직시하는 것이다.</p>

      <p>마케팅 문구: "AI가 코드를 작성합니다"</p>

      <p>현실: "AI가 초안을 만들고, 우리가 다시 작성합니다"</p>

      <p>오랫동안 개발하면서, 나는 모든 새로운 도구가 나타날 때마다 이런 사이클을 봤다:</p>

      <ol>
        <li>혁신적인 도구 등장 (마케팅 약속)</li>
        <li>초기 사용자들 대만족 (간단한 경우에만)</li>
        <li>복잡한 경우 맞닥뜨림 (문제 발생)</li>
        <li>현실적인 사용 영역 정착 (제한된 용도)</li>
      </ol>

      <p>AI 코딩 도구도 같은 경로를 가고 있다. 현재는 2단계와 3단계의 경계에 있다.</p>

      <p>당신이 해야 할 일은, 이 도구를 막는 것이 아니라, 현명하게 사용하는 것이다. 그리고 이 글에서 나누는 5가지 문제를 기억하면서.</p>

      <a class="back" href="/archive.html">&larr; 전체 글 목록으로</a>
    </article>
  </main>

  <footer class="site-footer">
    <div class="footer-inner">
      <p>&copy; 2026 Goldtag. All rights reserved.</p>
      <div class="footer-links">
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
        <a href="/contact.html">연락처</a>
      </div>
    </div>
  </footer>
</body>
</html>