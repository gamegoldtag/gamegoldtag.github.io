<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Cache-aside, write-through, SWR 패턴, Redis TTL, 무효화 전략, HTTP 헤더 활용">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-09.html">
  <title>API 캐시 전략 실전 — 응답 속도와 데이터 신선도를 함께 잡는 설계 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "API 캐시 전략 실전 — 응답 속도와 데이터 신선도를 함께 잡는 설계",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-04-15",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-09.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Backend &amp; DB</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>API 캐시 전략 실전 — 응답 속도와 데이터 신선도를 함께 잡는 설계</h1>
      <p class="meta">게시일: 2025년 4월 15일 · 15분 읽기</p>

<p>Redis 붙이면 끝이라고 생각했는데, 캐시 무효화가 진짜 지옥이었다.</p>

<p>우리 팀이 음성 채팅 앱의 백엔드에서 경험한 캐시 전략 실전기를 공유한다.</p>

<h3>문제: 캐시가 구원이라고 생각했다</h3>

<p>초기 설계:</p>

<blockquote>
<p>"모든 API 응답을 1시간 캐시하면 DB 부하가 90% 줄어들겠지?"</p>
</blockquote>

<p>결과:</p>

<blockquote>
<p>사용자 A가 설정을 바꿈 → 데이터 업데이트<br>
사용자 B가 같은 설정을 읽음 → 1시간 전 캐시된 데이터를 받음<br>
혼돈, 버그 리포트, 야식 디버깅</p>
</blockquote>

<p>캐시는 쌍날 검이었다.</p>

<h3>캐시 전략 1: Cache-Aside (Most Common)</h3>

<p>구조:</p>

<pre><code>클라이언트
  ↓
API 서버
  ├→ Redis (캐시)에 데이터가 있나?
  │   YES: 반환
  │   NO: DB에서 읽고, Redis에 저장, 반환
  ↓
Redis / Database
</code></pre>

<p>구현:</p>

<pre><code>async function getUserProfile(userId: string) {
    // 1. 캐시 확인
    const cached = await redis.get(`user:${userId}:profile`);
    if (cached) {
        return JSON.parse(cached);
    }

    // 2. 캐시 미스: DB에서 읽기
    const user = await db.users.findOne(userId);

    // 3. 캐시에 저장 (TTL: 1시간)
    await redis.setex(
        `user:${userId}:profile`,
        3600,  // seconds
        JSON.stringify(user)
    );

    return user;
}
</code></pre>

<p>장점:</p>

<ul>
<li>구현이 간단</li>
<li>캐시 미스 시에만 DB 접근</li>
</ul>

<p>단점:</p>

<ul>
<li>캐시 무효화가 복잡</li>
<li>데이터 업데이트 후 오래된 캐시를 읽을 수 있음</li>
</ul>

<h3>캐시 전략 2: Write-Through (데이터 일관성 중요)</h3>

<p>구조:</p>

<pre><code>쓰기 요청
  ↓
Redis에 쓰기
  ↓
DB에 쓰기 (순차 또는 병렬)
  ↓
응답
</code></pre>

<p>구현:</p>

<pre><code>async function updateUserProfile(userId: string, data: any) {
    // 1. 캐시에 업데이트
    const cacheKey = `user:${userId}:profile`;
    await redis.setex(cacheKey, 3600, JSON.stringify(data));

    // 2. DB에 업데이트
    await db.users.update(userId, data);

    return data;
}
</code></pre>

<p>장점:</p>

<ul>
<li>캐시와 DB 항상 일치</li>
<li>읽기가 항상 최신 데이터</li>
</ul>

<p>단점:</p>

<ul>
<li>쓰기가 느림 (캐시 + DB 둘 다)</li>
<li>캐시 쓰기 실패 시 불일치</li>
</ul>

<h3>캐시 전략 3: SWR (Stale-While-Revalidate)</h3>

<p>최신 데이터가 반드시 필요하지 않을 때:</p>

<pre><code>async function getMessages(conversationId: string) {
    const cached = await redis.get(`messages:${conversationId}`);

    if (cached) {
        // 1. 즉시 반환 (오래된 데이터라도)
        const data = JSON.parse(cached);

        // 2. 백그라운드에서 업데이트 (사용자 체감 없음)
        redis.setex(
            `messages:${conversationId}:updating`,
            1,
            '1'  // 업데이트 중 표시
        ).then(async () => {
            const fresh = await db.messages.findMany(conversationId);
            await redis.setex(
                `messages:${conversationId}`,
                300,  // 5분 TTL
                JSON.stringify(fresh)
            );
        });

        return data;  // 사용자는 바로 받음
    }

    // 캐시 미스: 기존 cache-aside
    const data = await db.messages.findMany(conversationId);
    await redis.setex(
        `messages:${conversationId}`,
        300,
        JSON.stringify(data)
    );

    return data;
}
</code></pre>

<p>장점:</p>

<ul>
<li>사용자 응답 시간 최고</li>
<li>백그라운드 업데이트로 항상 신선함</li>
</ul>

<p>단점:</p>

<ul>
<li>복잡도 증가</li>
<li>오래된 데이터를 먼저 받을 수 있음 (메시지 같은 경우 OK, 금액 같은 경우 NO)</li>
</ul>

<h3>실전: 캐시 무효화 패턴</h3>

<p>문제: 데이터가 업데이트되면 캐시를 지워야 한다.</p>

<h4>패턴 1: 명시적 무효화</h4>

<pre><code>async function updateUserName(userId: string, newName: string) {
    // 1. DB 업데이트
    await db.users.update(userId, { name: newName });

    // 2. 캐시 무효화 (명시적)
    await redis.del(`user:${userId}:profile`);
    await redis.del(`user:${userId}:settings`);
    // ...
}
</code></pre>

<p>문제: 연관된 모든 캐시 키를 기억해야 한다.</p>

<p>해결:</p>

<pre><code>// 패턴: 네임스페이스 관리
async function invalidateUserCache(userId: string) {
    // 와일드카드로 모든 user 캐시 삭제
    const keys = await redis.keys(`user:${userId}:*`);
    if (keys.length) {
        await redis.del(...keys);
    }
}
</code></pre>

<h4>패턴 2: TTL에 의존</h4>

<pre><code>// ✅ TTL에 따라 자동 무효화
await redis.setex(
    `messages:${conversationId}`,
    300,  // 5분 후 자동 삭제
    JSON.stringify(messages)
);

// 실시간 업데이트가 아니어도 괜찮은 데이터에 사용
</code></pre>

<h4>패턴 3: 버전 기반</h4>

<pre><code>// 캐시 키에 버전 포함
const version = user.updatedAt.getTime();
const cacheKey = `user:${userId}:profile:v${version}`;

await redis.setex(cacheKey, 86400, JSON.stringify(user));

// 데이터 업데이트 시 새 버전의 키가 생김
// 이전 캐시는 자연스럽게 오래됨
</code></pre>

<h3>HTTP 캐시 헤더</h3>

<p>또 다른 계층의 캐싱: 브라우저</p>

<pre><code>// Express.js 예시
app.get('/api/user/:id', (req, res) => {
    const user = getUser(req.params.id);

    res.set('Cache-Control', 'public, max-age=3600');  // 1시간
    res.set('ETag', `"${user.id}-${user.updatedAt}"`);

    res.json(user);
});
</code></pre>

<p>효과:</p>

<ul>
<li>캐시 헤더가 있으면 브라우저가 캐싱 (서버 요청 X)</li>
<li>ETag가 있으면 업데이트 확인 (If-None-Match)</li>
</ul>

<h3>Redis 구성: 성능과 안정성</h3>

<p>우리 구성:</p>

<pre><code>// Redis 클러스터
- 마스터: 1개 (쓰기)
- 복제본: 2개 (읽기)
- 센티널: 3개 (고가용성)

// 메모리 정책
maxmemory-policy: allkeys-lru
maxmemory: 16gb  // 가용 메모리의 70%

// 지속성
save 900 1      // 900초마다 최소 1개 키 변경 시 저장
appendonly yes  // AOF (Append-Only File) 사용
</code></pre>

<h3>캐시 워밍업 (Cache Warming)</h3>

<p>앱 시작 시 자주 사용되는 데이터를 미리 캐싱:</p>

<pre><code>// App startup
async function warmUpCache() {
    // 1. 인기 있는 대화 미리 로드
    const popularConversations = await db.conversations
        .find({ messageCount: { $gt: 100 } })
        .limit(1000);

    for (const conv of popularConversations) {
        const messages = await db.messages.findMany(conv.id);
        await redis.setex(
            `messages:${conv.id}`,
            3600,
            JSON.stringify(messages)
        );
    }

    console.log(`Warmed up cache for ${popularConversations.length} conversations`);
}

// main.ts
app.listen(3000, async () => {
    await warmUpCache();
    console.log('Server started');
});
</code></pre>

<h3>모니터링</h3>

<pre><code>// 캐시 히트율 추적
let cacheHits = 0;
let cacheMisses = 0;

async function getWithMetrics(key: string) {
    const cached = await redis.get(key);
    if (cached) {
        cacheHits++;
        return JSON.parse(cached);
    }
    cacheMisses++;
    // ...
}

// 1분마다 로그
setInterval(() => {
    const hitRate = cacheHits / (cacheHits + cacheMisses);
    console.log(`Cache hit rate: ${(hitRate * 100).toFixed(2)}%`);
}, 60000);
</code></pre>

<h3>결론: 캐시 전략 선택</h3>

<table>
<tr><th>전략</th><th>속도</th><th>데이터 일관성</th><th>사용처</th></tr>
<tr><td>Cache-Aside</td><td>빠름</td><td>느슨함</td><td>읽기 위주 (게시글)</td></tr>
<tr><td>Write-Through</td><td>느림</td><td>높음</td><td>일관성 중요 (계좌)</td></tr>
<tr><td>SWR</td><td>매우 빠름</td><td>중간</td><td>실시간 선호 (메시지)</td></tr>
</table>

<p>우리 음성 채팅 앱:</p>

<ul>
<li>사용자 프로필: Cache-Aside (1시간)</li>
<li>메시지 리스트: SWR (5분)</li>
<li>설정: Write-Through (즉시)</li>
</ul>

<p>캐시는 은탄환이 아니다. 전략을 잘 선택하면 성능과 데이터 일관성을 둘 다 얻을 수 있다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-61.html">
          <span class="ri-cat">Backend &amp; DB</span>
          <span class="ri-title">FastAPI vs Express — 2025년 백엔드 프레임워크 선택 기준</span>
        </a>
        <a class="related-item" href="/posts/post-64.html">
          <span class="ri-cat">Backend &amp; DB</span>
          <span class="ri-title">SQLite가 생각보다 강력한 이유 — 개인 프로젝트에서 PostgreSQL 대신</span>
        </a>
        <a class="related-item" href="/posts/post-66.html">
          <span class="ri-cat">Backend &amp; DB</span>
          <span class="ri-title">API 설계 원칙 — REST vs GraphQL, 실무에서 선택한 기준</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>