<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Electron 앱에서 Rust N-API 바인딩으로 오디오 처리 성능을 10배 개선한 실전 가이드. napi-rs 설정부터 CI 크로스 컴파일, 경계 최소화 설계까지 상세히 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-01.html">
  <title>Electron 앱에서 Rust로 네이티브 성능 확보하기: N-API 바인딩 실전 가이드 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>Electron 앱에서 Rust로 네이티브 성능 확보하기: N-API 바인딩 실전 가이드</h1>
      <p class="meta">게시일: 2026년 2월 10일 · 16분 읽기</p>

      <p>Electron 앱을 운영하다 보면 JavaScript 런타임만으로는 감당하기 어려운 CPU 작업이 반드시 등장합니다. 오디오 디코딩, 대용량 버퍼 처리, 암호화 연산처럼 지연이 바로 체감되는 영역에서는 네이티브 계층이 필요합니다.</p>

      <p>기존에는 C++ N-API 애드온을 사용했습니다. 성능 자체는 충분했지만, 메모리 안전성 문제로 인한 크래시가 주기적으로 발생했습니다. use-after-free, 버퍼 오버플로우 같은 문제들이 프로덕션에서 간헐적으로 나타났고, 재현이 어려워 디버깅에 많은 시간을 썼습니다. Rust로의 전환을 결정한 이유입니다.</p>

      <h2>왜 Rust를 선택했는가</h2>
      <p>Rust는 컴파일 단계에서 소유권과 빌림 규칙을 강제합니다. 메모리 안전성 문제의 대부분이 빌드 타임에 걸립니다. 동시에 C++에 가까운 실행 성능을 제공하므로, 안전성과 성능을 동시에 확보할 수 있었습니다.</p>

      <p>Node.js와의 연동 방법으로는 두 가지가 있었습니다:</p>
      <ul>
        <li><strong>node-bindgen:</strong> 간단한 연동에 적합, 기능 제한 있음</li>
        <li><strong>napi-rs:</strong> 더 풍부한 기능, 대용량 처리에 유리, 활발한 유지보수</li>
      </ul>
      <p>대용량 버퍼 처리와 비동기 작업이 핵심 요구사항이어서 <code>napi-rs</code>를 선택했습니다.</p>

      <h2>프로젝트 구조 설정</h2>

      <h3>Cargo.toml 설정</h3>
      <pre><code>[package]
name = "audio-native"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]  # Node.js가 로드 가능한 동적 라이브러리

[dependencies]
napi = { version = "2", features = ["napi8"] }
napi-derive = "2"

[profile.release]
lto = true          # Link-Time Optimization: 크기와 성능 최적화
codegen-units = 1   # 단일 코드 생성 유닛: 최적화 극대화
strip = true        # 디버그 심볼 제거</code></pre>

      <h3>기본 함수 노출</h3>
      <pre><code">// src/lib.rs
use napi_derive::napi;

#[napi]
pub fn process_audio_buffer(buffer: Vec&lt;f32&gt;, sample_rate: u32) -> Vec&lt;f32&gt; {
    // 오디오 처리 로직
    let processed: Vec&lt;f32&gt; = buffer.iter().map(|&amp;sample| {
        normalize_sample(sample, sample_rate)
    }).collect();

    processed
}

fn normalize_sample(sample: f32, _sample_rate: u32) -> f32 {
    sample.clamp(-1.0, 1.0)
}</code></pre>

      <h3>TypeScript에서 사용</h3>
      <pre><code">// Electron Main 또는 Preload에서 로드
const native = require('./native.node');

// 타입 정의 (napi-rs가 자동 생성 가능)
declare module './native.node' {
  export function processAudioBuffer(
    buffer: Float32Array,
    sampleRate: number
  ): Float32Array;
}

// 사용
const processed = native.processAudioBuffer(audioBuffer, 44100);</code></pre>

      <h2>비동기 처리: JavaScript를 블록하지 않기</h2>
      <p>CPU 집약적인 작업을 동기로 호출하면 Electron의 Main 또는 Renderer 스레드가 블록됩니다. napi-rs의 비동기 태스크를 사용해 별도 스레드에서 실행해야 합니다.</p>

      <pre><code">// src/lib.rs - 비동기 처리
use napi::bindgen_prelude::*;
use napi_derive::napi;

#[napi]
pub async fn process_large_buffer(buffer: Vec&lt;f32&gt;) -> Result&lt;Vec&lt;f32&gt;&gt; {
    // tokio 런타임에서 CPU 바운드 작업 실행
    let result = tokio::task::spawn_blocking(move || {
        heavy_computation(&amp;buffer)
    }).await.map_err(|e| napi::Error::from_reason(e.to_string()))?;

    Ok(result)
}

fn heavy_computation(buffer: &amp;[f32]) -> Vec&lt;f32&gt; {
    // 시간이 걸리는 연산
    buffer.iter().map(|&amp;x| x * x).collect()
}</code></pre>

      <pre><code">// JavaScript에서 await으로 사용
const result = await native.processLargeBuffer(buffer);
// 처리 중에도 UI가 응답함</code></pre>

      <h2>핫패스 선별: 무엇을 Rust로 옮길 것인가</h2>
      <p>처음부터 전면 전환하지 않았습니다. 먼저 Node.js 프로파일러로 실제 병목을 파악했습니다.</p>

      <pre><code">// Node.js 프로파일링으로 병목 구간 파악
// electron-main.js
const { Session } = require('inspector');
const session = new Session();
session.connect();

session.post('Profiler.enable', () => {
  session.post('Profiler.start', () => {
    // 측정할 작업 실행
    runAudioProcessing();

    session.post('Profiler.stop', (err, { profile }) => {
      require('fs').writeFileSync(
        'profile.json',
        JSON.stringify(profile)
      );
      console.log('Profile saved');
    });
  });
});</code></pre>

      <p>프로파일링 결과에서 전체 CPU 시간의 78%를 차지하는 함수 3개를 발견했습니다. 이 함수들만 Rust로 이전했고, 나머지는 그대로 JavaScript로 유지했습니다.</p>

      <div class="note">Rust로 이전할 가치가 있는 작업 기준: CPU 바운드이며, 단일 호출에 1ms 이상 소요되고, 초당 100번 이상 호출되는 경우.</div>

      <h2>경계 최소화 설계</h2>
      <p>JavaScript와 Rust 사이의 경계를 넘는 비용이 있습니다. 데이터 복사, 타입 변환, GC 체크포인트가 포함됩니다. 경계 횟수를 줄이는 것이 성능 최적화의 핵심입니다.</p>

      <pre><code">// Bad: 작은 함수를 반복 호출
for (const frame of frames) {
  result.push(native.processFrame(frame)); // 경계를 frames.length번 넘음
}

// Good: 한 번의 호출로 처리
const results = native.processAllFrames(frames); // 경계를 1번만 넘음</code></pre>

      <h2>크로스 플랫폼 빌드 설정</h2>
      <p>Electron 앱은 macOS, Windows, Linux를 모두 지원해야 하는 경우가 많습니다. 각 플랫폼별 바이너리를 GitHub Actions에서 빌드합니다.</p>

      <pre><code"># .github/workflows/build-native.yml
jobs:
  build:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
          - os: windows-latest
            target: x86_64-pc-windows-msvc
          - os: macos-latest
            target: x86_64-apple-darwin
          - os: macos-latest
            target: aarch64-apple-darwin  # Apple Silicon

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
        with:
          target: ${{ matrix.target }}

      - name: Build native module
        run: |
          cd native
          cargo build --release --target ${{ matrix.target }}

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: native-${{ matrix.target }}
          path: native/target/${{ matrix.target }}/release/*.node</code></pre>

      <h2>성과와 운영 관점</h2>
      <p>도입 후 6개월 운영 결과입니다:</p>
      <ul>
        <li><strong>성능:</strong> 동일 오디오 버퍼 기준 처리 시간 약 10배 단축</li>
        <li><strong>안정성:</strong> C++ 시절 발생하던 use-after-free 계열 크래시 0건</li>
        <li><strong>GC 영향 제거:</strong> JavaScript GC pause로 인한 끊김 현상 사라짐</li>
        <li><strong>배포:</strong> N-API ABI 안정성 덕분에 Node 버전 차이로 인한 호환성 문제 해결</li>
      </ul>

      <p>Rust 네이티브 모듈을 도입할 때 가장 중요한 두 가지 원칙은 <strong>"핫패스 선별"</strong>과 <strong>"경계 최소화"</strong>입니다. 모든 것을 Rust로 이전하려는 충동을 참고, 실제 병목만 선별해서 이전하면 Electron 앱의 체감 성능을 크게 개선할 수 있습니다.</p>

      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
