<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="TypeScript 5.x에서 실무에 바로 적용 가능한 타입 패턴을 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-02.html">
  <title>TypeScript 5.x 실전 타입 패턴 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.8; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 32px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 34px 0 12px; font-size: 1.2rem; }
    p { margin: 0 0 16px; }
    pre { background: #2d2d3f; color: #e6e6e6; padding: 16px; border-radius: 10px; overflow-x: auto; font-size: 0.9rem; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .back { display: inline-block; margin-top: 22px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>TypeScript 5.x의 실전 타입 패턴: 유지보수 비용을 줄이는 방법</h1>
      <p class="meta">게시일: 2026년 2월 5일 · 10분 읽기</p>
      <p>TypeScript를 오래 사용해도 프로젝트가 커지면 타입은 쉽게 무너집니다. 핵심은 타입을 많이 쓰는 것이 아니라, 변화 지점을 타입 시스템이 먼저 감지하도록 설계하는 것입니다. 아래 세 패턴은 실무에서 반복적으로 효과가 있었습니다.</p>
      <h2>1) Template Literal Types로 경로 제약</h2>
      <pre><code>type ApiVersion = 'v1' | 'v2';
type Resource = 'users' | 'tracks' | 'playlists';
type ApiPath = `${ApiVersion}/${Resource}`;
</code></pre>
      <p>경로 문자열을 런타임 문자열이 아니라 타입으로 모델링하면, 오타가 빌드 단계에서 바로 잡힙니다. API 증가 시에도 정의만 추가하면 호출부에 일관되게 반영됩니다.</p>
      <h2>2) Conditional Types로 응답 타입 자동 매핑</h2>
      <pre><code>type ApiResponse&lt;T extends ApiPath&gt; =
  T extends `${string}/users` ? User[] :
  T extends `${string}/tracks` ? Track[] :
  T extends `${string}/playlists` ? Playlist[] :
  never;
</code></pre>
      <p>엔드포인트별 응답 구조가 다를 때 가장 자주 쓰는 패턴입니다. 호출하는 순간 결과 타입이 자동 추론되어 다운스트림 코드의 단언 캐스팅이 크게 줄어듭니다.</p>
      <h2>3) satisfies로 검증과 추론 균형</h2>
      <p><code>satisfies</code>는 객체가 규약을 만족하는지 검증하면서도 리터럴 정보를 보존합니다. 설정 객체, 권한 맵, 라우팅 테이블처럼 정확한 키가 중요한 영역에서 특히 유용합니다.</p>
      <h2>실무 적용 기준</h2>
      <p>외부 API 경계는 엄격하게 타입화하고, 내부 모델은 과도한 제네릭보다 명시적 구조를 우선합니다. 복잡한 타입 유틸은 공용 패키지로 추출해 중복을 줄이면 리뷰 속도와 안정성이 함께 올라갑니다.</p>
      <p>TypeScript 5.x 시대에는 타입이 문서를 넘어 설계 검증기로 동작합니다. 이 변화가 팀 생산성의 분기점이 됩니다.</p>
      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
