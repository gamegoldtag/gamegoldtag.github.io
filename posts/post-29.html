<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="방화벽 뒤의 서버 접근. Local/remote/dynamic 포트 포워딩, SSH 터널 활용">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-29.html">
  <title>SSH 터널링 완전 정복 — 원격 서버 개발 환경 구축 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "SSH 터널링 완전 정복 — 원격 서버 개발 환경 구축",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-06-24",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-29.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">DevOps &amp; Infra</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>SSH 터널링 완전 정복 — 원격 서버 개발 환경 구축</h1>
      <p class="meta">게시일: 2025년 6월 24일 · 14분 읽기</p>

<h2>방화벽 뒤의 서버에 접근해야 할 때</h2>

<p>우리 회사의 데이터베이스 서버는 방화벽 뒤에 있다. VPN으로 접근할 수 있지만, VPN은 느리다. 게다가 로컬에서 직접 DB에 연결해서 개발하고 싶었다. 이때 SSH 터널링이 답이었다.</p>

<p>SSH 터널을 사용하면서 VPN 없이도 보안 연결을 할 수 있고, 속도도 훨씬 빠르다. 방법을 정리하겠다.</p>

<h3>로컬 포트 포워딩 (Local Port Forwarding)</h3>

<p>가장 기본적인 방식이다. 로컬의 포트를 원격 서버의 포트로 연결한다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# 형식
ssh -L [local-port]:[remote-host]:[remote-port] [ssh-user]@[ssh-host]

# 예: 로컬 3306 포트를 원격 DB 서버의 3306에 연결
ssh -L 3306:db.internal.com:3306 user@jump-host.example.com

# 이제 로컬에서
mysql -h localhost -P 3306 -u dbuser -p

# -N 플래그로 셸 실행 안 함
ssh -L 3306:db.internal.com:3306 -N user@jump-host.example.com
</code></pre>

<p>이제 로컬의 localhost:3306이 원격 DB와 연결된다. 마치 로컬에 DB가 있는 것처럼 작동한다.</p>

<h3>원격 포트 포워딩 (Remote Port Forwarding)</h3>

<p>반대로 원격 서버에서 로컬 포트에 접근하고 싶을 때:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# 형식
ssh -R [remote-port]:[local-host]:[local-port] [user]@[remote-host]

# 예: 원격 서버의 8000 포트를 로컬의 3000 포트로 연결
ssh -R 8000:localhost:3000 user@remote-server.com

# 이제 원격 서버에서
curl localhost:8000  # 로컬의 3000 포트로 접근됨
</code></pre>

<p>디버깅할 때 유용하다. 원격 서버의 테스트 스크립트가 로컬의 개발 서버에 요청을 보낼 수 있다.</p>

<h3>동적 포트 포워딩 (Dynamic Port Forwarding)</h3>

<p>모든 트래픽을 SSH를 통해 터널링하고 싶을 때:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# SOCKS 프록시 생성
ssh -D 1080 user@jump-host.example.com

# 이제 로컬의 1080 포트가 SOCKS 프록시 역할
# 브라우저나 앱에서 프록시 설정:
# SOCKS 호스트: localhost
# 포트: 1080

# 또는 curl에서
curl --socks5-hostname localhost:1080 http://internal.example.com
</code></pre>

<h3>ProxyJump와 Jump Host</h3>

<p>여러 서버를 거쳐서 접근할 때:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# ssh/config 파일에서
Host db-server
  HostName db.internal.com
  User postgres
  ProxyJump jump-host

Host jump-host
  HostName jump.example.com
  User ubuntu
  IdentityFile ~/.ssh/jump_key

# 이제 바로 접근 가능
ssh db-server  # 자동으로 jump-host를 거쳐서 연결됨

# 로컬 포트 포워딩도 자동으로 jump-host를 거친다
ssh -L 3306:db-server:3306 db-server
</code></pre>

<h3>VS Code Remote SSH</h3>

<p>SSH 터널을 VS Code와 통합하면 정말 강력하다:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# ssh/config
Host remote-dev
  HostName dev.example.com
  User developer
  ProxyJump jump-host
  IdentityFile ~/.ssh/dev_key
  ServerAliveInterval 60
  ServerAliveCountMax 3

// VS Code: Remote Explorer에서 remote-dev 선택
// 자동으로 SSH 연결되고, 원격 서버의 코드를 로컬에서 편집
// 터미널도 원격 서버의 터미널
</code></pre>

<h3>지속적인 연결 (Persistent Tunnel)</h3>

<p>항상 켜둔 터널이 필요할 때:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# Systemd 서비스로 등록 (Linux)
# ~/.config/systemd/user/ssh-tunnel.service
[Unit]
Description=SSH Tunnel to DB Server
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/ssh -N -L 3306:db.internal.com:3306 user@jump-host.example.com
Restart=always
RestartSec=5

[Install]
WantedBy=default.target

# 활성화
systemctl --user enable ssh-tunnel.service
systemctl --user start ssh-tunnel.service
</code></pre>

<p>macOS에서는 launchd를 쓴다:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# ~/Library/LaunchAgents/com.user.ssh-tunnel.plist
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;Label&lt;/key&gt;
  &lt;string&gt;com.user.ssh-tunnel&lt;/string&gt;
  &lt;key&gt;ProgramArguments&lt;/key&gt;
  &lt;array&gt;
    &lt;string&gt;/usr/bin/ssh&lt;/string&gt;
    &lt;string&gt;-N&lt;/string&gt;
    &lt;string&gt;-L&lt;/string&gt;
    &lt;string&gt;3306:db.internal.com:3306&lt;/string&gt;
    &lt;string&gt;user@jump-host.example.com&lt;/string&gt;
  &lt;/array&gt;
  &lt;key&gt;KeepAlive&lt;/key&gt;
  &lt;true/&gt;
  &lt;key&gt;RunAtLoad&lt;/key&gt;
  &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;

# 로드
launchctl load ~/Library/LaunchAgents/com.user.ssh-tunnel.plist
</code></pre>

<h3>보안 고려사항</h3>

<p>SSH 터널을 안전하게 사용하려면:</p>

<ul>
<li>Key-based authentication만 사용 (비밀번호 금지)</li>
<li>SSH 키에 passphrase 설정</li>
<li>ssh-agent로 키 관리</li>
<li>StrictHostKeyChecking 설정</li>
<li>로그 모니터링</li>
</ul>

<pre><code>&lt;?xml version="1.0"?&gt;
# ssh/config에서 보안 강화
Host *
  StrictHostKeyChecking accept-new
  AddKeysToAgent yes
  UseKeychain yes
  IdentitiesOnly yes

Host jump-host
  HostName jump.example.com
  User ubuntu
  IdentityFile ~/.ssh/id_jump_only
  # 특정 포트만 열기
  LocalForward 3306 db.internal.com:3306
</code></pre>

<h3>터널 모니터링</h3>

<pre><code>&lt;?xml version="1.0"?&gt;
# 활성 터널 확인
ps aux | grep ssh

# 더 자세한 정보
lsof -i :3306  # 3306 포트 사용 중인 프로세스

# SSH 연결 로그
ssh -v -L 3306:db.internal.com:3306 user@jump-host.example.com
</code></pre>

<h3>실전 예제</h3>

<p>우리 회사에서 사용하는 설정:</p>

<pre><code>&lt;?xml version="1.0"?&gt;
# ssh/config
Host prod-jump
  HostName jump.prod.example.com
  User devops
  IdentityFile ~/.ssh/prod_key
  ControlMaster auto
  ControlPath ~/.ssh/control-%h-%p-%r
  ControlPersist 600

Host prod-db
  HostName postgres.internal
  ProxyJump prod-jump
  User postgres
  IdentityFile ~/.ssh/prod_db_key

Host prod-api
  HostName api.internal
  ProxyJump prod-jump
  User ubuntu
  IdentityFile ~/.ssh/prod_api_key

Host dev-*
  ProxyJump prod-jump

# 터널 설정
LocalForward 5432 postgres.internal:5432  # DB
LocalForward 6379 redis.internal:6379     # Redis
LocalForward 9200 elasticsearch.internal:9200  # ES
</code></pre>

<h3>마무리</h3>

<p>SSH 터널링은 보안과 편의성을 동시에 제공한다. VPN보다 빠르고, 필요한 서비스만 로컬에 노출할 수 있다. 원격 개발 환경 구축에 필수적인 도구다.</p>

<p>처음엔 복잡해 보이지만, 한 번 설정해두면 정말 편하다. 특히 마이크로서비스 아키텍처에서는 여러 서버를 접근해야 하니까, 이런 설정이 있으면 개발 생산성이 크게 향상된다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-06.html">
          <span class="ri-cat">DevOps &amp; Infra</span>
          <span class="ri-title">WSL2 개발 환경 실전 세팅 — 네이티브 Linux 성능 비교까지</span>
        </a>
        <a class="related-item" href="/posts/post-41.html">
          <span class="ri-cat">DevOps &amp; Infra</span>
          <span class="ri-title">무료 호스팅 완전 비교 — GitHub Pages vs Cloudflare vs Vercel vs Netlify</span>
        </a>
        <a class="related-item" href="/posts/post-67.html">
          <span class="ri-cat">DevOps &amp; Infra</span>
          <span class="ri-title">HTTPS 무료 인증서 자동화 — Let&#x27;s Encrypt + certbot 완전 정복</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>