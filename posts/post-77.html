<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Rust의 테스트 시스템을 완벽히 이해하고 실전 예제로 배워봅시다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-77.html">
  <title>Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-12-09",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-77.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Rust</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기</h1>
      <p class="meta">게시일: 2025년 12월 9일 · 14분 읽기</p>
<p>Rust의 doc test는 혁신이다. 문서와 테스트가 동시에 최신 상태를 유지한다. 다른 언어에서는 이게 불가능하지만, Rust에서는 기본이다. 이 글에서는 Rust의 테스트 시스템을 완전히 마스터하는 방법을 설명한다.</p>

<h3>단위 테스트 — 같은 파일에서</h3>

<p>Rust의 관례는 테스트 모듈을 같은 파일에 작성하는 것이다.</p>

<pre><code class="language-rust">
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0);
        assert_eq!(add(0, 0), 0);
    }

    #[test]
    fn test_multiply() {
        assert_eq!(multiply(2, 3), 6);
        assert_eq!(multiply(-2, 3), -6);
    }

    #[test]
    #[should_panic]
    fn test_panic() {
        panic!("이 테스트는 panic이 예상된다");
    }
}
</code></pre>

<p>#[cfg(test)]는 컴파일 플래그로, cargo test 실행 시에만 컴파일된다. 프로덕션 바이너리에 포함되지 않는다.</p>

<h3>테스트 실행</h3>

<pre><code class="language-bash">
# 모든 테스트 실행
cargo test

# 특정 테스트 실행
cargo test test_add

# 테스트를 병렬이 아닌 순차적으로 실행
cargo test -- --test-threads=1

# 출력 표시 (기본적으로 passed 테스트의 출력은 숨겨짐)
cargo test -- --nocapture

# 무시된 테스트 실행
cargo test -- --ignored

# 모든 테스트 (무시된 것도 포함)
cargo test -- --include-ignored
</code></pre>

<h3>통합 테스트 — tests/ 디렉토리</h3>

<p>큰 기능은 통합 테스트로 테스트하는 것이 좋다. 이는 tests/ 디렉토리에 작성한다.</p>

<pre><code class="language-rust">
// tests/integration_test.rs
use my_crate::*;

#[test]
fn it_can_add_numbers() {
    assert_eq!(add(2, 3), 5);
}

#[test]
fn it_can_multiply_numbers() {
    assert_eq!(multiply(2, 3), 6);
}

#[test]
fn workflow_test() {
    // 실제 사용 흐름을 테스트
    let a = add(1, 2);  // 3
    let b = multiply(a, 2);  // 6
    assert_eq!(b, 6);
}
</code></pre>

<p>tests/ 디렉토리의 각 파일은 별도의 바이너리로 컴파일되므로, 라이브러리의 public API만 테스트할 수 있다.</p>

<h3>문서 테스트 — Doc Tests</h3>

<p>Rust의 문서화 코드는 자동으로 실행된다. 문서가 최신임을 보장한다.</p>

<pre><code class="language-rust">
/// 두 수를 더한다.
///
/// # Examples
///
/// ```
/// use my_crate::add;
///
/// assert_eq!(add(2, 3), 5);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

/// 팩토리얼을 계산한다.
///
/// # Panics
///
/// 음수가 입력되면 panic한다.
///
/// # Examples
///
/// ```
/// use my_crate::factorial;
///
/// assert_eq!(factorial(5), 120);
/// assert_eq!(factorial(0), 1);
/// ```
///
/// 음수 입력 시:
///
/// ```should_panic
/// use my_crate::factorial;
/// factorial(-1);
/// ```
pub fn factorial(n: u32) -> u32 {
    match n {
        0 | 1 => 1,
        _ => n * factorial(n - 1)
    }
}
</code></pre>

<p>cargo test를 실행하면 이 예제 코드들이 모두 실행된다.</p>

<pre><code class="language-bash">
# 문서 테스트만 실행
cargo test --doc

# 특정 함수의 문서 테스트만
cargo test --doc add
</code></pre>

<h3>테스트 Fixtures</h3>

<p>복잡한 테스트는 공통 설정이 필요하다.</p>

<pre><code class="language-rust">
#[cfg(test)]
mod tests {
    use super::*;

    struct TestContext {
        user: User,
        database: Database
    }

    fn setup() -> TestContext {
        let user = User::new("John", "john@example.com");
        let database = Database::new();
        TestContext { user, database }
    }

    #[test]
    fn test_user_creation() {
        let ctx = setup();
        assert_eq!(ctx.user.name, "John");
    }

    #[test]
    fn test_user_email() {
        let ctx = setup();
        assert_eq!(ctx.user.email, "john@example.com");
    }
}
</code></pre>

<h3>Property-Based Testing</h3>

<p>proptest 라이브러리를 사용하면 자동으로 다양한 입력값을 시도한다.</p>

<pre><code class="language-rust">
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::proptest;

    #[test]
    fn prop_add_is_commutative() {
        proptest!(|(a in -1000i32..1000, b in -1000i32..1000)| {
            // a + b == b + a 임을 여러 값으로 증명
            assert_eq!(add(a, b), add(b, a));
        });
    }

    #[test]
    fn prop_add_with_zero() {
        proptest!(|(a in -1000i32..1000)| {
            assert_eq!(add(a, 0), a);
        });
    }
}
</code></pre>

<h3>테스트 조직화</h3>

<p>큰 프로젝트에서는 src/ 안에 tests 모듈을 만들기도 한다.</p>

<pre><code class="language-rust">
// src/lib.rs
pub mod math;
pub mod utils;

#[cfg(test)]
mod tests;

// src/tests/mod.rs
mod math_tests;
mod utils_tests;
mod integration_tests;

// src/tests/math_tests.rs
#[cfg(test)]
mod tests {
    use crate::math::*;

    #[test]
    fn test_add() { ... }
}
</code></pre>

<h3>무시된 테스트</h3>

<p>느린 테스트는 무시할 수 있다.</p>

<pre><code class="language-rust">
#[test]
#[ignore]
fn expensive_test() {
    // 이 테스트는 cargo test 시 실행되지 않음
    // cargo test -- --ignored 로만 실행됨
}

#[test]
#[ignore = "데이터베이스가 필요함"]
fn database_test() {
    // 무시 이유도 기록 가능
}
</code></pre>

<h3>벤치마크 테스트</h3>

<p>Rust는 벤치마크 테스트도 지원한다 (nightly 필요).</p>

<pre><code class="language-rust">
#![feature(test)]
extern crate test;

#[cfg(test)]
mod benches {
    use super::*;
    use test::Bencher;

    #[bench]
    fn bench_add(b: &mut Bencher) {
        b.iter(|| add(2, 3));
    }

    #[bench]
    fn bench_multiply(b: &mut Bencher) {
        b.iter(|| multiply(2, 3));
    }
}
</code></pre>

<pre><code class="language-bash">
# 벤치마크 실행
cargo +nightly bench
</code></pre>

<h3>커버리지 측정</h3>

<pre><code class="language-bash">
# tarpaulin으로 커버리지 측정
cargo tarpaulin --out Html

# 또는 llvm-cov
cargo llvm-cov --html
</code></pre>

<h3>모범 사례</h3>

<ul>
<li><strong>각 함수마다 최소 3개의 테스트 케이스</strong>: 정상 케이스, 경계값, 에러 케이스</li>
<li><strong>Doc test 작성</strong>: 문서화와 테스트를 동시에</li>
<li><strong>의미 있는 테스트명</strong>: test_1 보다 test_add_positive_numbers</li>
<li><strong>한 테스트 한 가지만</strong>: 테스트가 실패했을 때 원인이 명확해야 함</li>
<li><strong>테스트도 코드</strong>: 테스트도 유지보수하고 리팩토링해야 함</li>
</ul>

<h3>결론</h3>

<p>Rust의 테스트 시스템은 언어에 깊이 통합되어 있다. 단위 테스트, 통합 테스트, 문서 테스트를 조합하면 매우 견고한 코드를 작성할 수 있다. 그리고 문서가 항상 최신이라는 것이 가장 큰 이점이다.</p>

      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>실무 개발자입니다. 현장에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-04.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체</span>
        </a>
        <a class="related-item" href="/posts/post-17.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust async/await 삽질 정리 — tokio 런타임에서 겪은 문제들</span>
        </a>
        <a class="related-item" href="/posts/post-60.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust lifetime이 어려운 이유와 실전 패턴 5가지</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>