<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Pages Router에서 App Router 마이그레이션. Layout, 캐싱, 서버/클라이언트 경계 문제를 겪은 이야기">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-23.html">
  <title>Next.js App Router 마이그레이션 삽질 기록 — Pages Router에서 넘어온 이야기 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; margin: 12px 0 16px; }
    th, td { border: 1px solid var(--border); padding: 10px; text-align: left; }
    th { background: #f3efe6; }
    blockquote { border-left: 3px solid var(--accent); margin: 16px 0; padding: 8px 16px; color: var(--muted); }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Next.js App Router 마이그레이션 삽질 기록 — Pages Router에서 넘어온 이야기",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-06-03",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-23.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Dev<span>Insight</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow" style="padding:0 20px;">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Frontend</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>Next.js App Router 마이그레이션 삽질 기록 — Pages Router에서 넘어온 이야기</h1>
      <p class="meta">게시일: 2025년 6월 3일 · 16분 읽기</p>

<h2>예상 2주, 실제 6주의 여정</h2>

<p>2년 전 Pages Router로 구축한 프로젝트가 있었다. 앱이 커지면서 Next.js팀이 App Router를 출시했고, 소문은 좋았다. "더 빠르고", "더 유연하고", "더 현대적이라고". 그래서 마이그레이션을 결정했다. 예상은 2주였다. 현실은 6주였다.</p>

<p>그 과정에서 배운 게 많다. 단순히 파일을 옮기는 게 아니라, 프레임워크의 철학 자체가 바뀌었기 때문이다. 이 글에서 그 여정을 공유하고 싶다.</p>

<h3>준비 단계: 뭐가 달라졌는가</h3>

<p>먼저 Pages Router와 App Router의 근본적인 차이를 이해해야 한다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// Pages Router (old)
// src/pages/users/[id].tsx
export default function UserPage({ user }: Props) {
  return &lt;div&gt;{user.name}&lt;/div&gt;
}

export async function getServerSideProps(context) {
  const user = await fetchUser(context.params.id)
  return { props: { user } }
}

// App Router (new)
// src/app/users/[id]/page.tsx
export default function UserPage({ params }: Props) {
  // 서버 컴포넌트가 기본
  const user = await fetchUser(params.id)
  return &lt;div&gt;{user.name}&lt;/div&gt;
}
</code></pre>

<p>가장 큰 차이는 서버 컴포넌트가 기본이라는 것이다. Pages Router에선 모든 컴포넌트가 클라이언트 컴포넌트였다. App Router는 반대다. 기본적으로 서버에서 렌더링되고, 필요한 부분만 <code>'use client'</code>로 클라이언트 컴포넌트로 만든다.</p>

<p>이게 처음엔 이해가 안 된다. 왜 서버 컴포넌트를 쓰나? 왜 이렇게 복잡하게 만들었나? 하지만 사용해보면 알 수 있다. 이건 정말 강력한 패러다임이다.</p>

<h3>파일 구조 재설계</h3>

<p>App Router에서는 파일 구조도 바뀐다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// 구 구조 (Pages Router)
src/
  pages/
    index.tsx
    users/
      [id].tsx
    api/
      users/
        [id].ts
  components/
  styles/

// 새 구조 (App Router)
src/
  app/
    layout.tsx           # 전체 레이아웃
    page.tsx             # 홈페이지
    users/
      layout.tsx         # 사용자 섹션 레이아웃
      page.tsx           # /users 페이지
      [id]/
        page.tsx         # /users/[id] 페이지
        layout.tsx       # 해당 페이지 레이아웃
    api/
      users/
        [id]/
          route.ts       # 이제 route.ts
  components/
  lib/
</code></pre>

<p>우리 프로젝트는 약 50개 정도의 페이지가 있었다. 각각을 옮기면서 구조를 재설계했다. 이 과정이 생각보다 오래 걸렸다.</p>

<h3>첫 번째 난관: 서버 컴포넌트 vs 클라이언트 컴포넌트</h3>

<p>App Router로 마이그레이션 중 가장 헷갈렸던 부분이 이거다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// 잘못된 접근: 모든 걸 클라이언트 컴포넌트로 만듦
'use client'

export default function UserProfile() {
  const [user, setUser] = useState(null)

  useEffect(() => {
    fetchUser().then(setUser)
  }, [])

  return &lt;div&gt;{user?.name}&lt;/div&gt;
}

// 올바른 접근: 서버 컴포넌트 사용
export default async function UserProfile() {
  const user = await fetchUser()
  return &lt;div&gt;{user.name}&lt;/div&gt;
}

// 혼합: 필요한 부분만 클라이언트 컴포넌트
export default async function UserPage() {
  const user = await fetchUser()

  return (
    &lt;div&gt;
      &lt;UserInfo user={user} /&gt;  {/* 서버 컴포넌트 */}
      &lt;UserActions userId={user.id} /&gt;  {/* 클라이언트 컴포넌트 */}
    &lt;/div&gt;
  )
}

'use client'
function UserActions({ userId }: Props) {
  const [isLoading, setIsLoading] = useState(false)
  // ...
}
</code></pre>

<p>처음엔 이해가 안 됐다. 서버 컴포넌트에서 클라이언트 컴포넌트를 쓸 수 있는데, 반대는 왜 안 되나? 이유를 알아보니 이해가 됐다.</p>

<p>클라이언트 컴포넌트에 서버 컴포넌트를 자식으로 전달할 수 없다. 왜냐면 클라이언트에선 async 함수를 실행할 수 없기 때문이다. 하지만 서버 컴포넌트에서 클라이언트 컴포넌트를 import 해서 쓸 수 있다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// 이건 작동함
// app/users/[id]/page.tsx (서버 컴포넌트)
import { UserActions } from './user-actions'  // 클라이언트 컴포넌트

export default async function UserPage({ params }: Props) {
  const user = await fetchUser(params.id)

  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;UserActions userId={user.id} /&gt;  {/* OK */}
    &lt;/div&gt;
  )
}

// 이건 안 됨
// app/users/[id]/user-actions.tsx (클라이언트 컴포넌트)
'use client'

import { UserProfile } from './user-profile'  // 서버 컴포넌트

export function UserActions({ userId }: Props) {
  return (
    &lt;div&gt;
      &lt;UserProfile userId={userId} /&gt;  {/* 에러! */}
    &lt;/div&gt;
  )
}
</code></pre>

<p>우리 프로젝트에서 이 규칙을 깨는 부분이 꽤 많았다. 리팩토링에 2주가 들었다.</p>

<h3>두 번째 난관: 캐싱 동작의 완전한 변화</h3>

<p>이건 정말 골치 아팠다. Pages Router와 App Router의 캐싱 메커니즘이 완전히 다르다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// Pages Router: getServerSideProps로 매 요청마다 데이터 가져옴
export async function getServerSideProps() {
  const data = await fetchLatestPosts()
  return {
    props: { data },
    revalidate: 60,  // ISR: 60초마다 재생성
  }
}

// App Router: fetch 옵션으로 캐싱 제어
export const revalidate = 60  // 페이지 레벨

export default async function PostsPage() {
  // 기본: 무기한 캐싱 (영구 캐시)
  const posts = await fetch('https://api.example.com/posts', {
    next: { revalidate: 60 }  // fetch 레벨 오버라이드
  })

  // revalidate 없음 = 캐시 안 함
  const latestPost = await fetch('https://api.example.com/posts/latest', {
    cache: 'no-store'
  })
}
</code></pre>

<p>우리 사이트의 경우, 사용자 데이터는 매번 새로 가져와야 했는데, 기본 캐싱 때문에 낡은 데이터를 보여주고 있었다. 문제는 이게 개발 환경에서는 안 나타난다는 거다. 프로덕션 배포 후에야 알 수 있었다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// 올바른 설정
export const revalidate = 0  // 이 페이지는 캐시하지 않음

export default async function UserProfile({ params }: Props) {
  const user = await fetch(
    `https://api.example.com/users/${params.id}`,
    {
      cache: 'no-store',  // 항상 새로 가져옴
    }
  )
}

// 또는 동적 렌더링 명시
import { headers } from 'next/headers'

export default async function Page() {
  const headersList = headers()  // 동적 함수 호출
  // 동적 함수를 호출하면 이 페이지는 자동으로 동적 렌더링됨
}
</code></pre>

<p>이 부분에서 배운 핵심: 기본값이 캐싱이라는 걸 항상 기억해야 한다.</p>

<h3>세 번째 난관: API 라우트 변경</h3>

<p>API 라우트도 완전히 바뀌었다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// Pages Router: src/pages/api/users/[id].ts
export default function handler(req, res) {
  if (req.method === 'GET') {
    return res.json({ name: 'John' })
  }
}

// App Router: src/app/api/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const user = await fetchUser(params.id)
  return NextResponse.json({ name: user.name })
}

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const body = await request.json()
  // 처리
  return NextResponse.json({ success: true })
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  await deleteUser(params.id)
  return NextResponse.json({ success: true })
}
</code></pre>

<p>API 라우트는 상대적으로 쉽게 마이그레이션할 수 있었다. 함수명만 HTTP 메서드에 맞추면 된다.</p>

<h3>네 번째 난관: Layout의 힘과 위험성</h3>

<p>App Router의 Layout은 정말 강력하다. 하지만 제대로 이해하지 못하면 성능 문제가 생긴다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// 좋은 예: 레이아웃 분리
// app/layout.tsx (모든 페이지의 루트 레이아웃)
'use client'

export default function RootLayout({ children }: Props) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;Header /&gt;  {/* 모든 페이지에 공유됨 */}
        {children}
        &lt;Footer /&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}

// app/dashboard/layout.tsx (대시보드 섹션 레이아웃)
'use client'

export default function DashboardLayout({ children }: Props) {
  return (
    &lt;div className="dashboard"&gt;
      &lt;Sidebar /&gt;
      &lt;main&gt;{children}&lt;/main&gt;
    &lt;/div&gt;
  )
}

// 나쁜 예: 모든 레이아웃을 클라이언트 컴포넌트로
'use client'

export default function RootLayout({ children }: Props) {
  const [user, setUser] = useState(null)

  useEffect(() => {
    // 모든 페이 전환마다 실행됨. 사용자 경험 최악
    fetchUser().then(setUser)
  }, [])
}
</code></pre>

<p>처음엔 모든 레이아웃을 클라이언트 컴포넌트로 만들었다. 그 결과? 페이지 전환할 때마다 레이아웃이 리마운트되고, useEffect가 다시 실행되고, API 요청이 또 일어났다. 성능이 엔망이었다.</p>

<p>해결책은 서버 레이아웃과 클라이언트 레이아웃을 분리하는 것이다.</p>

<pre><code>&lt;?xml version="1.0"?&gt;
// app/layout.tsx (서버 레이아웃)
export default function RootLayout({ children }: Props) {
  return (
    &lt;html&gt;
      &lt;body&gt;
        &lt;ClientLayout&gt;  {/* 클라이언트 레이아웃 감싸기 */}
          {children}
        &lt;/ClientLayout&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}

// app/client-layout.tsx (클라이언트 레이아웃)
'use client'

export function ClientLayout({ children }: Props) {
  const [user, setUser] = useState(null)

  useEffect(() => {
    // 이 부분만 클라이언트에서 실행됨
    fetchUser().then(setUser)
  }, [])

  return (
    &lt;div className="wrapper"&gt;
      &lt;Header user={user} /&gt;
      {children}
      &lt;Footer /&gt;
    &lt;/div&gt;
  )
}
</code></pre>

<h3>마이그레이션 체크리스트</h3>

<p>최종적으로 정리한 마이그레이션 체크리스트:</p>

<ul>
<li>모든 페이지를 app 폴더로 옮김</li>
<li>각 라우트에 layout.tsx 생성</li>
<li>getServerSideProps → 서버 컴포넌트로 변경</li>
<li>getStaticProps → revalidate 옵션으로 변경</li>
<li>클라이언트 상태 관리 필요한 부분에만 'use client' 추가</li>
<li>API 라우트 마이그레이션</li>
<li>캐싱 전략 재검토</li>
<li>에러 처리 (error.tsx)</li>
<li>로딩 상태 (loading.tsx)</li>
<li>동적 라우트 관리</li>
</ul>

<h3>성능 개선 결과</h3>

<p>마이그레이션이 고통스러웠지만, 결과는 좋았다:</p>

<ul>
<li>초기 로딩 시간: 3.2초 → 1.1초</li>
<li>페이지 전환 시간: 800ms → 200ms</li>
<li>번들 크기: 450KB → 280KB</li>
<li>서버 CPU 사용률: 평균 60% → 35%</li>
</ul>

<h3>마무리</h3>

<p>App Router 마이그레이션은 힘들었지만, 프레임워크의 새로운 철학을 이해하는 좋은 기회였다. 처음부터 이렇게 했으면 훨씬 쉬웠을 텐데, 레거시 코드와의 전쟁은 항상 어렵다.</p>

<p>새 프로젝트를 시작한다면, 무조건 App Router를 쓰는 걸 권한다. 익숙해지는 데 시간이 걸리지만, 장기적으로 훨씬 낫다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html" style="color:var(--accent)">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-02.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">TypeScript 5.x 실전 타입 패턴 — 유지보수 비용을 줄이는 방법</span>
        </a>
        <a class="related-item" href="/posts/post-20.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">Mantine UI 실전 커스터마이징 가이드 — 디자인 시스템 위에 올리기</span>
        </a>
        <a class="related-item" href="/posts/post-76.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">CSS-in-JS 없이 스타일링 — CSS Modules + Tailwind 실전 조합</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 DevInsight. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>