<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Ownership vs RAII, borrow checker 좌절, lifetime annotations, C++ 방식이 불가능한 이유">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-04.html">
  <title>C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; margin: 12px 0 16px; }
    th, td { border: 1px solid var(--border); padding: 10px; text-align: left; }
    th { background: #f3efe6; }
    blockquote { border-left: 3px solid var(--accent); margin: 16px 0; padding: 8px 16px; color: var(--muted); }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-03-28",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-04.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Dev<span>Insight</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow" style="padding:0 20px;">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Rust</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체</h1>
      <p class="meta">게시일: 2025년 3월 28일 · 17분 읽기</p>

<p>25년 C++을 쓰다가 Rust 컴파일러에게 매일 혼났다. 처음 6개월은 거의 전쟁이었다. "이게 컴파일되지 않는 건 말이 안 돼"라는 생각을 수백 번했다.</p>

<p>하지만 1년이 지나니까 깨달았다. C++의 방식이 사실 위험했던 것이다. Rust는 그 위험을 컴파일 타임에 막는 것뿐이다.</p>

<h3>C++과 Rust의 근본적인 차이</h3>

<p>C++에서는 이 코드가 완벽하게 작동한다:</p>

<pre><code>class AudioBuffer {
public:
    float* data;
    size_t size;

    AudioBuffer(size_t sz) : size(sz) {
        data = new float[size];
    }

    ~AudioBuffer() {
        delete[] data;
    }
};

void processAudio() {
    AudioBuffer* buffer = new AudioBuffer(1024);

    // 사용
    buffer-&gt;data[0] = 0.5f;

    // 명시적으로 delete
    delete buffer;  // ← 이걸 빼먹으면? 메모리 누수!
}
</code></pre>

<p>이건 RAII(Resource Acquisition Is Initialization) 패턴이다. C++ 커뮤니티는 이걸 "최선의 실무"라고 부른다. 하지만 실제로는 수백만 줄의 C++ 코드에서 delete를 빼먹는 실수가 발생한다.</p>

<p>Rust는 다르다:</p>

<pre><code>struct AudioBuffer {
    data: Vec&lt;f32&gt;,
}

impl AudioBuffer {
    fn new(size: usize) -&gt; Self {
        AudioBuffer {
            data: vec![0.0; size],
        }
    }
}

fn process_audio() {
    let mut buffer = AudioBuffer::new(1024);
    buffer.data[0] = 0.5;

    // buffer는 함수를 벗어날 때 자동으로 드롭됨
    // 개발자가 할 수 있는 일이 없음
}
</code></pre>

<p>Rust는 delete를 빼먹을 수 없다. 컴파일러가 강제한다.</p>

<h3>개념 1: Ownership — C++의 unique_ptr와는 다르다</h3>

<p>C++에서 unique_ptr를 쓰면:</p>

<pre><code>std::unique_ptr&lt;AudioBuffer&gt; buffer = std::make_unique&lt;AudioBuffer&gt;(1024);

// 다른 곳에 넘기기
std::unique_ptr&lt;AudioBuffer&gt; buffer2 = std::move(buffer);

// 이제 buffer는 nullptr? 아니다. 정의되지 않은 상태다.
// buffer에 접근하면... 컴파일러가 경고 안 함. 런타임 에러!
</code></pre>

<p>Rust에서는:</p>

<pre><code>let buffer = AudioBuffer::new(1024);
let buffer2 = buffer;  // ownership 이동

// 이제 buffer는 사용 불가
println!("{}", buffer.data[0]);  // ❌ 컴파일 에러!
// error[E0382]: borrow of moved value: `buffer`
</code></pre>

<p>C++에서는 런타임에 터질 수 있는 에러가, Rust에서는 컴파일 타임에 잡힌다.</p>

<h3>개념 2: Borrowing — 참조를 제어한다</h3>

<p>C++에서 참조를 쓰면:</p>

<pre><code>void modifyBuffer(AudioBuffer& buffer) {
    buffer.data[0] = 1.0;
}

void processAudio() {
    AudioBuffer buffer(1024);
    modifyBuffer(buffer);

    // buffer는 여전히 유효한가? 함수가 참조를 저장했다면?
    // 컴파일러는 알 수 없다.
}
</code></pre>

<p>문제는 함수 서명만으로는 알 수 없다는 것이다. modifyBuffer가 포인터를 저장했나? 아니면 사용만 했나?</p>

<p>Rust는 명시적이다:</p>

<pre><code>fn modify_buffer(buffer: &amp;mut AudioBuffer) {
    buffer.data[0] = 1.0;
}

fn process_audio() {
    let mut buffer = AudioBuffer::new(1024);
    modify_buffer(&amp;mut buffer);

    // 함수 signature에서 &amp;mut는 "임시 빌림"을 의미한다
    // 이 함수가 buffer의 ownership을 가져가지 않는다
    println!("{}", buffer.data[0]);  // ✅ OK, buffer는 여전히 유효
}
</code></pre>

<p>또한 Rust는 한 번에 하나의 mutable 참조만 허용한다:</p>

<pre><code>let mut buffer = AudioBuffer::new(1024);
let ref1 = &amp;mut buffer;
let ref2 = &amp;mut buffer;  // ❌ 컴파일 에러!
// error[E0499]: cannot borrow `buffer` as mutable more than once at a time

ref1.data[0] = 1.0;
ref2.data[0] = 2.0;  // 이건 뭐? 어느 것이 최종값?
</code></pre>

<p>C++에서는:</p>

<pre><code>AudioBuffer buffer(1024);
float* ptr1 = buffer.data;
float* ptr2 = buffer.data;

ptr1[0] = 1.0;
ptr2[0] = 2.0;

// 혼돈스럽지만 컴파일 됨. 데이터 레이스 가능성 있음.
</code></pre>

<h3>개념 3: Lifetime — 참조의 유효성 기간</h3>

<p>이것이 Rust의 가장 어려운 개념이다.</p>

<pre><code>// ❌ Rust 컴파일 에러
fn get_buffer_data() -&gt; &amp;Vec&lt;f32&gt; {
    let buffer = AudioBuffer::new(1024);
    &amp;buffer.data  // buffer는 함수 종료 후 드롭됨
    // 반환되는 참조는 무효해짐
}
</code></pre>

<p>C++에서는 컴파일되고, 런타임에 댕글링 포인터가 된다:</p>

<pre><code>// C++ - 위험
const float* getBufferData() {
    AudioBuffer buffer(1024);
    return buffer.data;  // buffer가 드롭되면서 data 포인터는 무효
}

void processAudio() {
    const float* data = getBufferData();
    printf("%f", data[0]);  // 정의되지 않은 동작!
}
</code></pre>

<p>Rust는 이 문제를 컴파일 타임에 방지한다.</p>

<h3>개념 4: 왜 C++ 방식이 불가능한가</h3>

<p>C++의 관례:</p>

<pre><code>// C++ 설계 패턴
class StreamProcessor {
private:
    std::vector&lt;AudioBuffer*&gt; buffers;  // 포인터 저장

public:
    void addBuffer(AudioBuffer* buffer) {
        buffers.push_back(buffer);  // 포인터만 저장, ownership 불명확
    }

    void processAll() {
        for (auto buffer : buffers) {
            if (buffer) {  // 유효한가? 누가 delete 했나?
                process(*buffer);
            }
        }
    }
};
</code></pre>

<p>누가 buffer를 소유하는가? 누가 delete해야 하는가? 주석에 쓸 수밖에 없다:</p>

<pre><code>// buffer의 lifetime은 caller가 관리
// StreamProcessor는 buffer를 delete하지 않음
// ← 이걸 실수하면 메모리 누수 또는 use-after-free
</code></pre>

<p>Rust는 이것을 불가능하게 한다:</p>

<pre><code>struct StreamProcessor {
    buffers: Vec&lt;AudioBuffer&gt;,  // ownership을 가짐
}

impl StreamProcessor {
    fn add_buffer(&amp;mut self, buffer: AudioBuffer) {
        self.buffers.push(buffer);  // ownership 이동
    }

    fn process_all(&amp;self) {
        for buffer in &amp;self.buffers {
            self.process(buffer);
        }
    }
}
</code></pre>

<p>ownership이 명확하다. StreamProcessor가 buffers를 소유하므로 드롭될 때 자동으로 cleanup된다.</p>

<h3>좌절: Borrow Checker와의 싸움</h3>

<p>처음 Rust로 짠 코드:</p>

<pre><code>fn process_frame(
    buffer: &amp;mut Vec&lt;f32&gt;,
    filters: &amp;Vec&lt;Filter&gt;,
) {
    for i in 0..buffer.len() {
        let sample = buffer[i];

        for filter in filters {
            let processed = filter.apply(sample);
            buffer[i] = processed;  // ❌ 에러!
        }
    }
}

// error[E0502]: cannot borrow `buffer` as mutable because it is also borrowed as immutable
</code></pre>

<p>내 생각: "어? buffer를 mutable로만 빌렸는데?"</p>

<p>컴파일러의 말: "buffer[i]를 읽을 때 immutable borrow가 됐고, 다시 쓰려고 하니까 mutable borrow가 필요해. 동시에 둘 다 불가능해."</p>

<p>해결책: 인덱스를 쓴다:</p>

<pre><code>fn process_frame(
    buffer: &amp;mut Vec&lt;f32&gt;,
    filters: &amp;Vec&lt;Filter&gt;,
) {
    for i in 0..buffer.len() {
        for filter in filters {
            let processed = filter.apply(buffer[i]);
            buffer[i] = processed;  // ✅ OK
        }
    }
}
</code></pre>

<p>처음엔 답답했다. 하지만 이 규칙이 있어서 데이터 레이스가 일어날 수 없다.</p>

<h3>예제: C++ vs Rust 멀티스레드</h3>

<p>C++에서 공유 데이터:</p>

<pre><code>class AudioMixer {
private:
    std::vector&lt;float&gt; output;  // 여러 스레드에서 접근

public:
    void addSample(int index, float value) {
        output[index] += value;  // 스레드 안전? 아니다!
        // 여러 스레드가 동시에 접근 → 데이터 레이스
    }
};
</code></pre>

<p>C++ 개발자는 이 버그를 뮤텍스로 막는다:</p>

<pre><code>class AudioMixer {
private:
    std::mutex lock;
    std::vector&lt;float&gt; output;

public:
    void addSample(int index, float value) {
        std::lock_guard&lt;std::mutex&gt; guard(lock);
        output[index] += value;  // 안전
    }
};
</code></pre>

<p>하지만 뮤텍스를 빼먹을 수 있다. 다른 곳에서는 lock 없이 접근할 수 있다.</p>

<p>Rust에서는:</p>

<pre><code>struct AudioMixer {
    output: Mutex&lt;Vec&lt;f32&gt;&gt;,
}

impl AudioMixer {
    fn add_sample(&amp;self, index: usize, value: f32) {
        let mut output = self.output.lock().unwrap();
        output[index] += value;
    }
}

// 다른 스레드
let mixer = Arc::new(AudioMixer::new());
let mixer_clone = Arc::clone(&amp;mixer);

std::thread::spawn(move || {
    mixer_clone.add_sample(0, 0.5);
});
</code></pre>

<p>Rust는 Mutex 없이는 여러 스레드에서 접근 불가능하게 한다. 컴파일러가 강제한다.</p>

<h3>배운 것들</h3>

<blockquote>
<p>1. C++의 "최선의 실무"는 사실 좋은 관례일 뿐, 컴파일러가 강제할 수 없다<br>
2. Rust의 ownership은 처음엔 답답하지만, 버그를 근본에서 막는다<br>
3. 컴파일 타임 안전성은 런타임 성능을 희생하지 않는다 (0-cost abstraction)<br>
4. 멀티스레드 코드는 Rust가 훨씬 안전하다</p>
</blockquote>

<h3>결론</h3>

<p>25년 C++을 쓴 나도 이제는 시스템 프로그래밍을 Rust로 한다. 처음 6개월의 고통은 가치가 있다. 뒤돌아보면 C++의 use-after-free 디버깅에 보냈던 시간을 생각나면, Rust의 borrow checker와의 싸움따위는 사소하다.</p>

<p>Rust는 어렵지만, 그 어려움이 버그를 막는다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html" style="color:var(--accent)">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-15.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 에러 처리 패턴 — anyhow vs thiserror, 실전에서 뭘 써야 하나</span>
        </a>
        <a class="related-item" href="/posts/post-58.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 크로스 컴파일 — Windows/macOS/Linux 한 번에 빌드하기</span>
        </a>
        <a class="related-item" href="/posts/post-77.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 DevInsight. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>