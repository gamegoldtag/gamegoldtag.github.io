<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="C++ 개발자가 Rust로 전환하며 겪은 소유권 시스템의 실체, 흔한 컴파일 에러 패턴, 팀 도입 전략을 코드 예시와 함께 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-04.html">
  <title>C++ 개발자가 Rust로 전환하며 배운 것들 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>C++ 개발자가 Rust로 전환하며 배운 것들: 소유권 시스템의 실체</h1>
      <p class="meta">게시일: 2026년 1월 20일 · 15분 읽기</p>

      <p>C++를 10년 넘게 쓰다 Rust로 전환했을 때 가장 먼저 든 감정은 답답함이었습니다. 뻔해 보이는 코드를 컴파일러가 거부하고, 오류 메시지는 이해하기 어려운 수명(lifetime) 표기로 가득했습니다. 그러나 6개월이 지난 시점에서 돌아보면, Rust 컴파일러가 거부했던 코드들은 C++ 환경에서 실제로 장애를 일으켰을 패턴들이었습니다.</p>

      <p>이 글은 C++ 경험자가 Rust를 배울 때 겪는 구체적인 어려움과, 그것을 넘어서는 과정을 정리합니다. 이론보다 실제 코드 패턴 중심으로 설명합니다.</p>

      <h2>소유권 시스템: C++와 다른 것들</h2>
      <p>C++에서는 메모리 관리가 개발자 책임입니다. 스마트 포인터(<code>unique_ptr</code>, <code>shared_ptr</code>)로 상당 부분을 자동화할 수 있지만, 컴파일러가 강제하지는 않습니다. Rust는 소유권 규칙을 컴파일러가 강제합니다.</p>

      <p>핵심 규칙은 세 가지입니다:</p>
      <ul>
        <li>모든 값은 소유자가 하나입니다</li>
        <li>소유자가 스코프를 벗어나면 값은 자동 해제됩니다</li>
        <li>값은 이동(move)하거나 빌림(borrow)할 수 있습니다</li>
      </ul>

      <pre><code>// C++: 이런 코드가 컴파일되고 런타임에 문제 발생 가능
std::string s = "hello";
std::string* ptr = &s;
// s를 다른 곳에 move 후 ptr을 역참조 → use-after-move (UB)

// Rust: 같은 패턴이 컴파일 타임에 거부됨
let s = String::from("hello");
let r = &s;
let s2 = s; // s 이동 발생
println!("{}", r); // 컴파일 에러: r이 참조하는 s가 이동됨
// error[E0505]: cannot move out of `s` because it is borrowed</code></pre>

      <h2>전환 초기에 가장 자주 만나는 컴파일 에러</h2>

      <h3>E0382: 이동된 값 사용</h3>
      <pre><code>let v = vec![1, 2, 3];
let v2 = v;          // v의 소유권이 v2로 이동
println!("{:?}", v); // 에러: value used here after move

// 해결 1: clone
let v2 = v.clone();

// 해결 2: 참조로 전달
let v2 = &v;
println!("{:?}", v); // OK: v는 여전히 소유자</code></pre>

      <h3>E0502: 가변 참조와 불변 참조 동시 존재</h3>
      <pre><code>let mut v = vec![1, 2, 3];
let r = &v;           // 불변 참조
v.push(4);            // 에러: v에 가변 참조가 필요한데 불변 참조가 살아있음
println!("{:?}", r);

// 해결: 불변 참조 사용 후 가변 참조
let r = &v;
println!("{:?}", r);  // r 사용 완료
v.push(4);            // 이제 가능</code></pre>

      <h3>수명(lifetime) 에러</h3>
      <p>수명 에러는 처음에 가장 난해하게 느껴지는 부분입니다. 핵심은 "반환값이 입력 참조보다 오래 살아남지 않는다"는 것을 컴파일러에 알려주는 것입니다.</p>

      <pre><code>// 에러: 반환 참조의 수명이 불명확
fn longest(s1: &str, s2: &str) -&gt; &str {
    if s1.len() &gt; s2.len() { s1 } else { s2 }
}

// 수정: 수명 파라미터로 명시
fn longest&lt;'a&gt;(s1: &'a str, s2: &'a str) -&gt; &'a str {
    if s1.len() &gt; s2.len() { s1 } else { s2 }
}
// 'a는 s1과 s2 중 짧은 수명을 따른다는 의미</code></pre>

      <h2>C++ 패턴을 Rust로 옮기기</h2>

      <h3>RAII → Drop trait</h3>
      <pre><code>// C++ RAII
class FileGuard {
    FILE* f;
public:
    FileGuard(const char* path) { f = fopen(path, "r"); }
    ~FileGuard() { if (f) fclose(f); }
};

// Rust: Drop이 자동 구현됨
use std::fs::File;
let file = File::open("path.txt")?;
// file이 스코프를 벗어나면 자동으로 닫힘
// Drop trait을 명시적으로 구현할 수도 있음</code></pre>

      <h3>nullable 포인터 → Option</h3>
      <pre><code>// C++: nullptr 체크를 빠뜨리면 런타임 크래시
std::string* find_user(int id) {
    // 못 찾으면 nullptr 반환
}
auto user = find_user(42);
user-&gt;name; // user가 nullptr면 segfault

// Rust: 컴파일러가 None 처리를 강제
fn find_user(id: u32) -&gt; Option&lt;User&gt; {
    // 못 찾으면 None 반환
}
match find_user(42) {
    Some(user) =&gt; println!("{}", user.name),
    None =&gt; println!("User not found"),
}</code></pre>

      <h3>예외 → Result</h3>
      <pre><code>// C++: 예외 처리 누락 가능
void process_file(const std::string& path) {
    // 예외 던질 수 있음, 호출자가 무시 가능
}

// Rust: 에러 처리를 타입으로 강제
fn process_file(path: &str) -&gt; Result&lt;(), io::Error&gt; {
    let content = fs::read_to_string(path)?; // ? 연산자로 에러 전파
    // 처리 로직
    Ok(())
}
// 반환값을 무시하면 컴파일 경고</code></pre>

      <h2>스레드 안전성: C++ vs Rust</h2>
      <p>C++에서 스레드 간 데이터 공유는 개발자가 뮤텍스를 올바르게 사용하는지 직접 보장해야 합니다. Rust는 <code>Send</code>와 <code>Sync</code> 트레이트로 컴파일 타임에 스레드 안전성을 검증합니다.</p>

      <pre><code>// Rust: 스레드 간 안전하지 않은 공유는 컴파일 에러
use std::thread;

let v = vec![1, 2, 3];
// v는 Send를 구현하므로 스레드 간 이동 가능
let handle = thread::spawn(move || {
    println!("{:?}", v);
});

// Arc&lt;Mutex&lt;T&gt;&gt;: 여러 스레드에서 공유 가능한 가변 데이터
use std::sync::{Arc, Mutex};
let shared = Arc::new(Mutex::new(vec![1, 2, 3]));
let shared_clone = Arc::clone(&shared);

thread::spawn(move || {
    let mut v = shared_clone.lock().unwrap();
    v.push(4);
});</code></pre>

      <h2>C++ 개발자가 빠르게 Rust에 익숙해지는 방법</h2>
      <p>직접 경험한 학습 경로를 정리합니다:</p>

      <ol>
        <li><strong>rustlings 완료:</strong> 작은 예제로 소유권, 빌림, 수명을 반복 체험</li>
        <li><strong>컴파일 에러를 두려워하지 않기:</strong> Rust 컴파일러의 에러 메시지는 C++ 대비 훨씬 친절합니다. 에러 메시지를 끝까지 읽으면 해결 방법이 나옵니다.</li>
        <li><strong>clippy와 cargo fmt 생활화:</strong> <code>cargo clippy</code>는 더 나은 Rust 코드를 제안합니다</li>
        <li><strong>처음부터 unsafe를 피하기:</strong> <code>unsafe</code> 없이도 대부분의 시스템 프로그래밍이 가능합니다</li>
      </ol>

      <h2>실무 전환 전략</h2>
      <p>팀 전체가 한꺼번에 Rust로 전환하면 러닝 커브로 인한 생산성 저하가 생깁니다. 안전한 전환 전략은 다음과 같습니다:</p>
      <ul>
        <li><strong>독립 배치 작업이나 CLI 도구부터:</strong> 비즈니스 로직과 분리된 도구에서 먼저 경험을 쌓습니다</li>
        <li><strong>성능이 중요한 핫패스:</strong> 기존 C++ 코드의 병목 구간을 Rust FFI로 교체</li>
        <li><strong>코드 리뷰 기준 문서화:</strong> 소유권 이동, borrow 범위, Result 처리, unwrap 사용 기준을 팀 문서로 정리</li>
        <li><strong>Rust 숙련자 1명 먼저:</strong> 팀에서 최소 1명이 먼저 깊이 배운 뒤 내부 교육 진행</li>
      </ul>

      <h2>마무리</h2>
      <p>Rust 전환의 가장 큰 장점은 "이 코드가 런타임에 문제가 생길까?"라는 불안을 없애준다는 점입니다. C++에서 런타임에 잡히던 클래스의 버그들이 빌드 단계에서 차단됩니다. 초기 러닝 커브는 실재하지만, 안정성과 성능을 동시에 요구하는 영역에서는 충분히 투자 가치가 있습니다.</p>

      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
