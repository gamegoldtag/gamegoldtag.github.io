<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Result/Option patterns, anyhow for apps, thiserror for libs, error conversion, ? operator chains">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-15.html">
  <title>Rust 에러 처리 패턴 — anyhow vs thiserror, 실전에서 뭘 써야 하나 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Rust 에러 처리 패턴 — anyhow vs thiserror, 실전에서 뭘 써야 하나",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-05-06",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-15.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Rust</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>Rust 에러 처리 패턴 — anyhow vs thiserror, 실전에서 뭘 써야 하나</h1>
      <p class="meta">게시일: 2025년 5월 6일 · 14분 읽기</p>

<p>unwrap() 남발하다가 프로덕션에서 panic 터졌다. Rust의 에러 처리를 제대로 배웠다.</p>

<h3>anyhow vs thiserror</h3>

<p>두 라이브러리의 목적은 다르다:</p>

<blockquote>
<p>anyhow: 애플리케이션에서 사용 (빠른 개발)<br>
thiserror: 라이브러리에서 사용 (명확한 에러 타입)</p>
</blockquote>

<h3>anyhow: 빠른 에러 처리</h3>

<p>애플리케이션이라면 anyhow:</p>

<pre><code>use anyhow::Result;

async fn process_audio(file_path: &amp;str) -> Result&lt;()&gt; {
    let content = std::fs::read(file_path)
        .context("Failed to read audio file")?;

    let decoded = decode_audio(&amp;content)
        .context("Failed to decode audio")?;

    save_processed(&amp;decoded)
        .context("Failed to save processed audio")?;

    Ok(())
}

// main
#[tokio::main]
async fn main() {
    match process_audio("voice.wav").await {
        Ok(_) => println!("Success"),
        Err(e) => {
            eprintln!("Error: {}", e);  // ← 전체 error chain 출력
            std::process::exit(1);
        }
    }
}
</code></pre>

<p>장점:</p>

<ul>
<li>쉽고 빠르다</li>
<li>에러 체인 자동 생성 (.context())</li>
<li>에러 타입을 강제하지 않음</li>
</ul>

<h3>thiserror: 명확한 에러 타입</h3>

<p>라이브러리라면 thiserror (또는 커스텀 enum):</p>

<pre><code>use thiserror::Error;

#[derive(Error, Debug)]
pub enum AudioError {
    #[error("Failed to read file: {0}")]
    FileRead(#[from] std::io::Error),

    #[error("Invalid audio format: {0}")]
    InvalidFormat(String),

    #[error("Decoding failed: {0}")]
    DecodingError(String),

    #[error("Unsupported sample rate: {0}")]
    UnsupportedSampleRate(u32),
}

pub fn decode_audio(data: &amp;[u8]) -> Result&lt;Vec&lt;f32&gt;, AudioError&gt; {
    if data.len() &lt; 4 {
        return Err(AudioError::InvalidFormat(
            "Data too short".to_string()
        ));
    }

    // ...
    Ok(samples)
}

// 사용처에서 특정 에러를 처리 가능
match decode_audio(data) {
    Ok(samples) => { /* ... */ }
    Err(AudioError::InvalidFormat(msg)) => {
        println!("Invalid format: {}", msg);
    }
    Err(AudioError::UnsupportedSampleRate(rate)) => {
        println!("Unsupported rate: {}", rate);
    }
    Err(e) => {
        eprintln!("Other error: {}", e);
    }
}
</code></pre>

<p>장점:</p>

<ul>
<li>호출자가 특정 에러를 처리 가능</li>
<li>타입 안전</li>
<li>라이브러리 사용자에게 명확</li>
</ul>

<h3>실전 패턴</h3>

<h4>패턴 1: ? 연산자</h4>

<pre><code>fn process() -> Result&lt;()&gt; {
    let file = std::fs::read("data.txt")?;  // ← Err 시 즉시 반환
    let data = parse(&amp;file)?;
    save(&amp;data)?;
    Ok(())
}
</code></pre>

<h4>패턴 2: map_err로 에러 변환</h4>

<pre><code>fn parse_number(s: &amp;str) -> Result&lt;i32, AudioError&gt; {
    s.parse()
        .map_err(|_| AudioError::InvalidFormat(
            format!("Cannot parse: {}", s)
        ))
}
</code></pre>

<h4>패턴 3: custom_context (anyhow)</h4>

<pre><code>fn process_file(path: &amp;str) -> anyhow::Result&lt;()&gt; {
    let content = std::fs::read(path)
        .with_context(|| format!("Failed to read: {}", path))?;

    Ok(())
}

// 에러 메시지
// Error: Failed to read: voice.wav
//
// Caused by:
//     No such file or directory (os error 2)
</code></pre>

<h3>panic vs Result</h3>

<p>나쁜 패턴:</p>

<pre><code>// ❌ 절대 금지
let data = std::fs::read("voice.wav").unwrap();  // panic!
let sample_rate: u32 = data[0..4].iter().sum();  // panic!
</code></pre>

<p>좋은 패턴:</p>

<pre><code>// ✅ 좋음
let data = std::fs::read("voice.wav")
    .context("Failed to read voice file")?;

let sample_rate = u32::from_le_bytes(
    data[0..4].try_into()
        .context("Invalid header length")?
);
</code></pre>

<h3>에러 복구</h3>

<p>예시: 네트워크 요청 재시도</p>

<pre><code>async fn fetch_with_retry(url: &amp;str) -> anyhow::Result&lt;String&gt; {
    const MAX_RETRIES: u32 = 3;

    for attempt in 1..=MAX_RETRIES {
        match fetch(url).await {
            Ok(data) => return Ok(data),
            Err(e) if attempt &lt; MAX_RETRIES =&gt; {
                eprintln!("Attempt {} failed: {}, retrying...", attempt, e);
                tokio::time::sleep(Duration::from_secs(2_u64.pow(attempt))).await;
            }
            Err(e) => return Err(e).context("Failed after all retries"),
        }
    }

    unreachable!()
}
</code></pre>

<h3>결론</h3>

<p>Rust 에러 처리는 엄격하지만, 그 덕분에 런타임 에러가 줄어든다.</p>

<blockquote>
<p>애플리케이션: anyhow 사용<br>
라이브러리: thiserror로 명확한 타입 정의<br>
복구 가능한 에러: Result&lt;T, E&gt;<br>
복구 불가능한 에러: panic! (드물게)</p>
</blockquote>

<p>프로덕션에서 panic이 터지는 건 최악이다. Rust의 Result 타입을 믿고 사용하자.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-04.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">C++ 개발자가 Rust로 전환하며 배운 것들 — 소유권 시스템의 실체</span>
        </a>
        <a class="related-item" href="/posts/post-58.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 크로스 컴파일 — Windows/macOS/Linux 한 번에 빌드하기</span>
        </a>
        <a class="related-item" href="/posts/post-77.html">
          <span class="ri-cat">Rust</span>
          <span class="ri-title">Rust 테스트 전략 — 단위/통합/문서 테스트 제대로 쓰기</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>