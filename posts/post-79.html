<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="DNS 해석, TCP 핸드셰이크, HTTP/2, TLS 1.3, CDN을 상세히 설명합니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-79.html">
  <title>개발자가 알면 좋은 네트워크 기초 — DNS부터 TCP까지 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; margin: 12px 0 16px; }
    th, td { border: 1px solid var(--border); padding: 10px; text-align: left; }
    th { background: #f3efe6; }
    blockquote { border-left: 3px solid var(--accent); margin: 16px 0; padding: 8px 16px; color: var(--muted); }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "개발자가 알면 좋은 네트워크 기초 — DNS부터 TCP까지",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2026-02-20",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-79.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Dev<span>Insight</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow" style="padding:0 20px;">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">개발 기초 &amp; 팁</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>개발자가 알면 좋은 네트워크 기초 — DNS부터 TCP까지</h1>
      <p class="meta">게시일: 2026년 2월 20일 · 15분 읽기</p>
<p>DNS 캐시 때문에 배포 후 30분 동안 옛 버전이 나왔다. 네트워크의 기초를 모르면 이런 디버깅을 못한다. 이 글에서는 개발자가 알아야 할 네트워크 기초를 설명한다.</p>

<h3>DNS 해석 과정</h3>

<p>브라우저가 example.com을 방문하면, 다음의 과정이 일어난다.</p>

<pre><code class="language-text">
1. 로컬 캐시 확인 (브라우저 캐시)
2. OS 캐시 확인
3. Recursive Resolver 질문 (ISP DNS)
4. Root Nameserver 질문
5. TLD Nameserver 질문 (.com을 담당하는 서버)
6. Authoritative Nameserver 질문 (example.com 담당)
7. 응답이 역순으로 돌아옴
8. 각 단계에서 캐싱됨
</code></pre>

<p><strong>실제 과정 추적</strong></p>

<pre><code class="language-bash">
# DNS 해석 추적
dig example.com

# 출력 분석:
; <<>> DiG 9.10.6 <<>> example.com
;; Query time: 45 msec  # 쿼리 시간
;; SERVER: 8.8.8.8#53(8.8.8.8)  # 사용한 네임서버

# 상세 추적
dig +trace example.com  # 전체 경로 표시
nslookup example.com    # 간단한 버전
</code></pre>

<p><strong>TTL 이해</strong></p>

<p>TTL (Time To Live)은 DNS 응답을 얼마나 오래 캐시할 것인지를 지시한다.</p>

<pre><code class="language-bash">
# TTL 확인
dig example.com | grep example.com

# 출력:
example.com.		3600	IN	A	93.184.216.34
            ↑
           TTL: 3600초 (1시간)
</code></pre>

<p>배포 전에 TTL을 낮추면, 변경이 빠르게 반영된다.</p>

<pre><code class="language-bash">
# TTL을 300초(5분)로 설정
# DNS 레코드 설정에서:
example.com.  300  IN  A  93.184.216.34

# 또는 프로그래밍으로
import dns.resolver
answers = dns.resolver.resolve('example.com', 'A', lifetime=5)
</code></pre>

<h3>TCP 3-Way Handshake</h3>

<p>TCP 연결은 3개의 패킷 교환으로 시작된다.</p>

<pre><code class="language-text">
클라이언트                  서버
    |                       |
    |--- SYN (seq=100) ---->|
    |                       | (SYN 수신)
    |<-- SYN-ACK (seq=300, ack=101) --|
    | (SYN-ACK 수신)        |
    |--- ACK (seq=101, ack=301) ---->|
    |                       | (ACK 수신)
    |  연결 확립!            |
</code></pre>

<p>각 단계:</p>

<ol>
<li><strong>SYN</strong>: 클라이언트가 시퀀스 번호를 보냄</li>
<li><strong>SYN-ACK</strong>: 서버가 수신했음을 확인하고 자신의 시퀀스 번호를 보냄</li>
<li><strong>ACK</strong>: 클라이언트가 서버의 시퀀스 번호를 확인</li>
</ol>

<p><strong>RTT (Round Trip Time) 측정</strong></p>

<pre><code class="language-bash">
# ping으로 RTT 확인
ping example.com

# 또는 curl로
curl -w 'Connect time: %{time_connect}s
' example.com

# HTTP/2 연결 시간 분석
curl -w '@-' -o /dev/null -s << 'EOF'
    time_namelookup:  %{time_namelookup}

    time_connect:     %{time_connect}

    time_appconnect:  %{time_appconnect}

    time_pretransfer: %{time_pretransfer}

    time_starttransfer: %{time_starttransfer}

    time_total:       %{time_total}

EOF
</code></pre>

<h3>HTTP/2 멀티플렉싱</h3>

<p>HTTP/1.1에서는 한 번에 하나의 요청만 처리한다. HTTP/2는 여러 요청을 동시에 처리한다.</p>

<pre><code class="language-text">
HTTP/1.1:
요청1 -----> [처리] -----> 응답1
              요청2 -----> [처리] -----> 응답2
                           요청3 -----> [처리] -----> 응답3

HTTP/2 (멀티플렉싱):
요청1 요청2  |-----> [처리] -----> 응답1,2,3
요청3 /        (동시 처리)
</code></pre>

<p><strong>HTTP/2 사용 확인</strong></p>

<pre><code class="language-bash">
# HTTP/2 지원 확인
curl -I --http2 https://example.com

# 또는 curl -v로 상세 확인
curl -v --http2 https://example.com
# HTTP/2.0 200 이 보이면 HTTP/2 사용 중
</code></pre>

<h3>HTTP/3 QUIC</h3>

<p>HTTP/3는 QUIC 프로토콜을 사용한다. TCP 대신 UDP 기반이다.</p>

<table>
<thead>
<tr>
<th>프로토콜</th>
<th>기반</th>
<th>0-RTT</th>
<th>멀티플렉싱</th>
<th>연결 마이그레이션</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP/1.1</td>
<td>TCP</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>HTTP/2</td>
<td>TCP</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>HTTP/3</td>
<td>QUIC</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>

<p>0-RTT는 캐시된 세션으로 첫 패킷부터 데이터를 보낼 수 있다는 뜻이다. 매우 빠르다.</p>

<h3>TLS 1.3 Handshake</h3>

<p>TLS도 핸드셰이크 과정이 있다. TLS 1.3은 1.2보다 빠르다.</p>

<pre><code class="language-text">
TLS 1.2 (2 Round Trips):
클라이언트 -----> ClientHello
           <----- ServerHello, Cert, ServerKeyExchange, ServerHelloDone
           -----> ClientKeyExchange, ChangeCipherSpec, Finished
           <----- ChangeCipherSpec, Finished
           (이제야 암호화된 통신 가능)

TLS 1.3 (1 Round Trip):
클라이언트 -----> ClientHello + (예상하는 키 교환)
           <----- ServerHello + Cert + Finished (암호화됨)
           -----> Finished
           (바로 암호화된 통신 시작)
</code></pre>

<p><strong>TLS 버전 확인</strong></p>

<pre><code class="language-bash">
# OpenSSL로 확인
openssl s_client -connect example.com:443

# Protocol 줄을 보면 버전이 표시됨
# TLSv1.3이면 최신
</code></pre>

<h3>CDN과 엣지 캐싱</h3>

<p>CDN은 콘텐츠를 전 세계 여러 위치에 캐시한다.</p>

<pre><code class="language-bash">
# CDN 확인
curl -I https://example.com | grep -i "via\|server\|cache"

# 또는 nslookup으로 IP의 위치 추적
nslookup example.com
# 여러 IP가 반환되면 CDN 사용 중
</code></pre>

<p><strong>캐시 헤더 설정</strong></p>

<pre><code class="language-javascript">
// Express.js에서
app.get('/static/*', (req, res) => {
  res.set('Cache-Control', 'public, max-age=31536000');  // 1년
  res.sendFile(req.path);
});

app.get('/api/*', (req, res) => {
  res.set('Cache-Control', 'no-cache, no-store');  // 캐시 없음
  // ...
});

app.get('/dynamic/*', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600, s-maxage=86400');
  // 브라우저: 1시간, CDN: 1일
  // ...
});
</code></pre>

<h3>네트워크 디버깅 도구</h3>

<p><strong>curl 심화</strong></p>

<pre><code class="language-bash">
# 상세 정보 출력
curl -v https://example.com

# 성능 측정
curl -w '@-' -o /dev/null -s << 'EOF'
time_namelookup:  %{time_namelookup}s

time_connect:     %{time_connect}s

time_appconnect:  %{time_appconnect}s

time_starttransfer: %{time_starttransfer}s

time_total:       %{time_total}s

EOF

# Headers만 확인
curl -I https://example.com

# HTTP/1.1 강제
curl --http1.1 https://example.com

# HTTP/2 강제
curl --http2 https://example.com
</code></pre>

<p><strong>traceroute - 경로 추적</strong></p>

<pre><code class="language-bash">
# 패킷의 경로 추적
traceroute example.com

# 또는 mtr (더 상세)
mtr example.com
</code></pre>

<p><strong>Network tab in DevTools</strong></p>

<p>브라우저의 Network 탭은 가장 강력한 도구다.</p>

<ul>
<li>각 요청의 상세 정보</li>
<li>응답 헤더 및 바디</li>
<li>캐시 상태</li>
<li>연결 시간 분석</li>
</ul>

<h3>실전 디버깅 사례</h3>

<p><strong>DNS 캐시 문제</strong></p>

<p>배포 후 옛 버전이 계속 나오는 경우:</p>

<pre><code class="language-bash">
# 1. 로컬 DNS 캐시 확인
nslookup example.com

# 2. 글로벌 DNS 캐시 사이트로 확인
# whatsmydns.net에서 여러 네임서버의 응답 확인

# 3. TTL이 높으면 낮춤
# DNS 제공자에서 TTL을 300초로 낮추기

# 4. 강제 갱신
# Windows: ipconfig /flushdns
# Mac: sudo dscacheutil -flushcache
# Linux: sudo systemctl restart systemd-resolved
</code></pre>

<p><strong>느린 연결 문제</strong></p>

<pre><code class="language-bash">
# 1. RTT 측정
ping example.com

# 2. 해석 시간 확인
dig example.com

# 3. DNS 서버 변경
# /etc/resolv.conf (Linux)
nameserver 8.8.8.8
nameserver 8.8.4.4

# 4. 성능 재측정
curl -w 'Total time: %{time_total}s
' example.com
</code></pre>

<h3>정리</h3>

<p>네트워크 기초의 핵심:</p>

<ul>
<li><strong>DNS</strong>: 도메인 이름을 IP로 변환 (캐시가 중요)</li>
<li><strong>TCP</strong>: 신뢰할 수 있는 연결 (3-way handshake)</li>
<li><strong>TLS</strong>: 암호화된 통신 (1.3이 더 빠름)</li>
<li><strong>HTTP</strong>: 애플리케이션 프로토콜 (버전이 성능에 영향)</li>
<li><strong>CDN</strong>: 콘텐츠 배포 네트워크 (캐시 설정이 중요)</li>
</ul>

<p>이 기础를 이해하면, 네트워크 문제를 빠르게 진단하고 해결할 수 있다.</p>

      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>28년 경력의 개발자. 실무에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html" style="color:var(--accent)">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-11.html">
          <span class="ri-cat">개발 기초 &amp; 팁</span>
          <span class="ri-title">E2E 테스트 flaky 줄이기 — 실패 원인을 구조적으로 제거하는 방법</span>
        </a>
        <a class="related-item" href="/posts/post-71.html">
          <span class="ri-cat">개발 기초 &amp; 팁</span>
          <span class="ri-title">Playwright vs Cypress — 2025년 E2E 테스트 도구 비교</span>
        </a>
        <a class="related-item" href="/posts/post-75.html">
          <span class="ri-cat">개발 기초 &amp; 팁</span>
          <span class="ri-title">Chrome DevTools 숨겨진 기능 — 디버깅 시간 줄이는 팁 모음</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 DevInsight. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>