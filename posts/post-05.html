<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="3년 된 SPA 마이그레이션, 라우트 레벨 분할, 데이터 페칭 변경, hydration 문제 해결">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-05.html">
  <title>React 19 Server Components 도입기 — 레거시 SPA를 점진적으로 마이그레이션하기 | Goldtag</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2446729462046987"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/gowun-batang@5.0.20/700.css">
  <link rel="stylesheet" href="/style.css">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "React 19 Server Components 도입기 — 레거시 SPA를 점진적으로 마이그레이션하기",
    "author": { "@type": "Person", "name": "ian.lab" },
    "publisher": { "@type": "Person", "name": "ian.lab" },
    "datePublished": "2025-04-01",
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://ikakao.kr/posts/post-05.html" }
  }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <a class="logo" href="/">Gold<span>tag</span></a>
      <nav class="nav-links" aria-label="주요 메뉴">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
      </nav>
    </div>
  </header>

  <div class="container-narrow">
    <nav class="breadcrumb" aria-label="경로">
      <a href="/">홈</a><span class="sep">/</span>
      <a href="/archive.html">Frontend</a><span class="sep">/</span>
      <span>현재 글</span>
    </nav>
  </div>

  <main class="post-wrap">
    <article class="post-card">
      <h1>React 19 Server Components 도입기 — 레거시 SPA를 점진적으로 마이그레이션하기</h1>
      <p class="meta">게시일: 2025년 4월 1일 · 16분 읽기</p>

<p>3년 된 SPA를 한 번에 갈아엎자는 건 자살행위다. 우리 팀은 React 19 Server Components를 6개월에 걸쳐 점진적으로 도입했다. 지난 회의에서 한 CTO의 말이 기억난다:</p>

<blockquote>
<p>"번들 사이즈 50% 감소? 초기 로딩 3배 빨라짐? 이게 진짜냐?"</p>
</blockquote>

<p>진짜였다. 이 경험을 공유한다.</p>

<h3>문제: 레거시 SPA의 한계</h3>

<p>우리의 음성 채팅 웹앱은:</p>

<ul>
<li>Next.js 12 + React 17</li>
<li>모든 페이지가 client-side 렌더링</li>
<li>초기 번들 크기 2.4MB</li>
<li>초기 로딩 시간 4.2초</li>
<li>SEO 매우 나쁨</li>
</ul>

<p>문제는 이것이었다:</p>

<blockquote>
<p>1. 모든 데이터 페칭 로직이 useEffect에 있음 → waterfall requests<br>
2. 모든 npm 패키지가 클라이언트에 번들됨 → 무거움<br>
3. 보안: API 키가 클라이언트 코드에 노출<br>
4. SEO: 동적 메타태그가 작동 안 함</p>
</blockquote>

<h3>Step 1: Next.js 14 업그레이드 (App Router 도입)</h3>

<p>먼저 Pages Router에서 App Router로 옮겼다. 이 과정은 사실 Server Components 도입의 준비였다.</p>

<p>이전 구조 (Pages Router):</p>

<pre><code>// pages/calls/[id].tsx
export default function CallPage({ call }: Props) {
    const [messages, setMessages] = useState([]);

    useEffect(() => {
        fetch(`/api/calls/${id}/messages`)
            .then(r =&gt; r.json())
            .then(setMessages);
    }, [id]);

    return (
        &lt;div&gt;
            {messages.map(m =&gt; &lt;Message key={m.id} msg={m} /&gt;)}
        &lt;/div&gt;
    );
}
</code></pre>

<p>새로운 구조 (App Router):</p>

<pre><code>// app/calls/[id]/page.tsx
export default async function CallPage({ params }) {
    const messages = await db.query.callMessages.findMany({
        where: { callId: params.id }
    });

    return (
        &lt;div&gt;
            {messages.map(m =&gt; &lt;Message key={m.id} msg={m} /&gt;)}
        &lt;/div&gt;
    );
}
</code></pre>

<p>이게 정말 큰 차이다. 클라이언트에서 API 호출 대신, 서버에서 데이터를 직접 가져온다.</p>

<h3>Step 2: Client Components로 상호작용 분리</h3>

<p>모든 걸 Server Component로 할 순 없다. 상호작용이 필요한 부분은 Client Component여야 한다.</p>

<p>좋은 분리:</p>

<pre><code>// app/calls/[id]/page.tsx (Server Component)
export default async function CallPage({ params }) {
    const call = await db.query.calls.findOne(params.id);
    const messages = await db.query.callMessages.findMany({
        where: { callId: params.id }
    });

    return (
        &lt;&gt;
            &lt;div&gt;
                &lt;h1&gt;{call.title}&lt;/h1&gt;
                &lt;p&gt;Started at {call.startedAt}&lt;/p&gt;
            &lt;/div&gt;

            {/* Client Component: 상호작용 있음 */}
            &lt;MessagesContainer initialMessages={messages} callId={params.id} /&gt;
        &lt;/&gt;
    );
}

// components/MessagesContainer.tsx (Client Component)
'use client';

export function MessagesContainer({ initialMessages, callId }) {
    const [messages, setMessages] = useState(initialMessages);
    const [input, setInput] = useState('');

    const sendMessage = async () => {
        const response = await fetch(`/api/calls/${callId}/messages`, {
            method: 'POST',
            body: JSON.stringify({ text: input }),
        });
        const newMessage = await response.json();
        setMessages(m =&gt; [...m, newMessage]);
        setInput('');
    };

    return (
        &lt;div&gt;
            {messages.map(m =&gt; &lt;Message key={m.id} msg={m} /&gt;)}
            &lt;input value={input} onChange={e =&gt; setInput(e.target.value)} /&gt;
            &lt;button onClick={sendMessage}&gt;Send&lt;/button&gt;
        &lt;/div&gt;
    );
}
</code></pre>

<p>이 분리가 성능의 핵심이다. 정적인 콘텐츠(call 제목)는 서버에서 렌더링되고, 상호작용 부분(메시지 입력)만 클라이언트에 간다.</p>

<h3>Step 3: 라우트 레벨 분할</h3>

<p>점진적 마이그레이션을 위해 라우트별로 나눴다:</p>

<blockquote>
<p>주 1회 1-2개 라우트씩 Server Components로 전환</p>
</blockquote>

<p>마이그레이션 순서:</p>

<pre><code>Week 1: /home (정적, 데이터 없음)
Week 2: /docs (정적, 마크다운)
Week 3: /calls/[id] (동적이지만 읽기만)
Week 4: /settings (사용자 정보, 업데이트 필요)
...
</code></pre>

<h3>Step 4: 데이터 페칭 패턴 변경</h3>

<p>Server Components에서 데이터를 가져오는 방식:</p>

<pre><code>// ✅ 좋음: 병렬 페칭
export default async function CallPage({ params }) {
    // 이 두 요청은 병렬로 실행됨
    const [call, participants, messages] = await Promise.all([
        db.calls.findOne(params.id),
        db.participants.findMany({ callId: params.id }),
        db.messages.findMany({ callId: params.id }),
    ]);

    return &lt;CallView call={call} participants={participants} messages={messages} /&gt;;
}
</code></pre>

<p>비교: 클라이언트에서 (waterfall):</p>

<pre><code>// ❌ 나쁨: 직렬 페칭
useEffect(() => {
    fetch(`/api/calls/${id}`)
        .then(r =&gt; r.json())
        .then(call =&gt; {
            fetch(`/api/calls/${id}/participants`)  // ← call 로드 후에야 시작
                .then(r =&gt; r.json())
                .then(setParticipants);
        });
}, [id]);
</code></pre>

<p>서버에서는 모두 동시에 시작된다.</p>

<h3>Step 5: Hydration 문제 해결</h3>

<p>처음 몇 페이지 마이그레이션 후 hydration mismatch 에러가 터졌다:</p>

<blockquote>
<p>Hydration failed because the initial UI does not match what was rendered on the server.</p>
</blockquote>

<p>원인: Client Component에서 초기 상태가 서버 렌더링과 다르면 발생한다.</p>

<p>나쁜 예:</p>

<pre><code>// ❌ Hydration mismatch 발생
'use client';

export function Timestamp() {
    const [time, setTime] = useState('');

    useEffect(() => {
        setTime(new Date().toISOString());
    }, []);

    return &lt;p&gt;{time}&lt;/p&gt;  // 초기값: ''(서버), 1초 후: '2024-08-08T...'(클라이언트)
}
</code></pre>

<p>좋은 예:</p>

<pre><code>// ✅ 일치함
'use client';

interface TimestampProps {
    initialTime: string;  // 서버에서 받음
}

export function Timestamp({ initialTime }: TimestampProps) {
    const [time, setTime] = useState(initialTime);

    useEffect(() => {
        setTime(new Date().toISOString());
    }, []);

    return &lt;p&gt;{time}&lt;/p&gt;  // 초기값: initialTime(일치)
}
</code></pre>

<p>또는 suppressHydrationWarning을 쓸 수 있지만, 이건 임시방편이다:</p>

<pre><code>// 임시방편
&lt;p suppressHydrationWarning&gt;{time}&lt;/p&gt;
</code></pre>

<h3>Step 6: API 전략 변경</h3>

<p>Server Components에서는 데이터베이스에 직접 접근할 수 있다. API routes가 필요 없어진다.</p>

<p>이전:</p>

<pre><code>// pages/api/calls/[id].ts
export default async function handler(req, res) {
    const call = await db.calls.findOne(req.query.id);
    res.json(call);
}

// pages/calls/[id].tsx
const [call, setCall] = useState(null);
useEffect(() => {
    fetch(`/api/calls/${id}`)
        .then(r =&gt; r.json())
        .then(setCall);
}, [id]);
</code></pre>

<p>이후:</p>

<pre><code>// app/calls/[id]/page.tsx (Server Component)
const call = await db.calls.findOne(id);

// API routes는 동적 요청(POST 등)에만 필요
// pages/api/calls/[id]/messages.ts (POST 메시지 생성)
</code></pre>

<h3>성능 개선 결과</h3>

<table>
<tr><th>메트릭</th><th>이전 (SPA)</th><th>이후 (Server Components)</th><th>개선</th></tr>
<tr><td>초기 JS 번들</td><td>2.4MB</td><td>1.2MB</td><td>50%</td></tr>
<tr><td>First Contentful Paint</td><td>4.2s</td><td>1.4s</td><td>67%</td></tr>
<tr><td>Time to Interactive</td><td>6.1s</td><td>2.8s</td><td>54%</td></tr>
<tr><td>API 요청 수 (홈페이지)</td><td>8</td><td>0</td><td>100%</td></tr>
</table>

<h3>배운 점</h3>

<blockquote>
<p>1. 모든 데이터 페칭을 클라이언트에서 할 필요는 없다<br>
2. 정적 콘텐츠를 서버에서 렌더링하면 번들이 줄어든다<br>
3. 보안: API 키를 서버에만 두고 클라이언트에 노출 안 함<br>
4. 점진적 마이그레이션이 가능하고, 혼합해서 쓸 수 있다</p>
</blockquote>

<h3>결론</h3>

<p>Server Components는 혁신이다. 하지만 마이그레이션은 신중해야 한다. 우리는 6개월에 걸쳐 50개 라우트를 옮겼다. 급하게 할 필요는 없다. 점진적이 답이다.</p>


      <div class="author-box">
        <div class="author-avatar">iL</div>
        <div class="author-info">
          <strong>ian.lab</strong>
          <p>오랫동안 실무를 해온 개발자입니다. 현장에서 겪은 문제와 해결 과정을 기록합니다. 오류 제보는 <a href="/contact.html">연락처</a>로 보내주세요.</p>
        </div>
      </div>

      <div class="related-posts">
        <h3>관련 글 더 보기</h3>
        <div class="related-list">
        <a class="related-item" href="/posts/post-02.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">TypeScript 5.x 실전 타입 패턴 — 유지보수 비용을 줄이는 방법</span>
        </a>
        <a class="related-item" href="/posts/post-21.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">Vite 설정 최적화 — 빌드 속도와 개발 경험 동시에 잡기</span>
        </a>
        <a class="related-item" href="/posts/post-76.html">
          <span class="ri-cat">Frontend</span>
          <span class="ri-title">CSS-in-JS 없이 스타일링 — CSS Modules + Tailwind 실전 조합</span>
        </a>
        </div>
      </div>
    </article>
</main>

  <footer class="site-footer">
    <div class="footer-inner">
      <div class="footer-links">
        <a href="/">홈</a>
        <a href="/archive.html">전체 글</a>
        <a href="/about.html">소개</a>
        <a href="/contact.html">연락처</a>
        <a href="/editorial-policy.html">운영 원칙</a>
        <a href="/privacy.html">개인정보처리방침</a>
        <a href="/terms.html">이용약관</a>
      </div>
      <div class="footer-copy">
        &copy; 2026 Goldtag. All rights reserved.<br>
        기술 정보는 실제 사용 환경에 맞게 검토 후 적용하세요.
      </div>
    </div>
  </footer>
</body>
</html>