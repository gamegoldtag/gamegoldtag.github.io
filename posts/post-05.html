<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="레거시 React SPA를 React 19 Server Components로 점진 마이그레이션한 실전 경험. 도입 순서, 캐시 설계, 측정 지표까지 상세히 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-05.html">
  <title>React 19 Server Components 점진 도입기 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .warn { background: #fff2ef; border: 1px solid #f1c2b8; border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>React 19 Server Components 도입기: 레거시 SPA를 점진적으로 마이그레이션하기</h1>
      <p class="meta">게시일: 2026년 1월 14일 · 14분 읽기</p>

      <p>3년 된 React SPA를 Server Components로 전환한다는 계획이 확정됐을 때, 팀 내 첫 반응은 "전부 다시 짜야 하는 거 아니냐"였습니다. 실제로는 달랐습니다. 전략적으로 접근하면 기능 회귀 없이 점진적으로 이전할 수 있었고, 오히려 한 번에 전환했다면 놓쳤을 구조적 문제들을 중간에 발견할 수 있었습니다.</p>

      <p>이 글은 실제 마이그레이션 과정에서 겪은 의사결정과 실수, 그리고 결과를 공유합니다. Next.js App Router 기반으로 진행했습니다.</p>

      <h2>Server Components를 도입하는 이유 재정리</h2>
      <p>Server Components의 핵심 가치는 두 가지입니다:</p>
      <ul>
        <li><strong>데이터 패칭을 서버에서:</strong> 클라이언트 번들에 데이터 패칭 코드가 들어가지 않고, 네트워크 왕복 횟수가 줄어듭니다. 컴포넌트가 직접 데이터베이스나 API를 호출할 수 있습니다.</li>
        <li><strong>클라이언트 JS 번들 감소:</strong> Server Component는 클라이언트로 JS가 전달되지 않습니다. 렌더링 결과만 전달됩니다.</li>
      </ul>

      <p>다만 이 장점이 자동으로 실현되지는 않습니다. 설계 없이 도입하면 캐시 문제와 데이터 불일치로 더 복잡해질 수 있습니다.</p>

      <h2>도입 전 현황 파악: 데이터 패턴 분류</h2>
      <p>마이그레이션을 시작하기 전에 기존 앱의 데이터 패칭 패턴을 먼저 분류했습니다:</p>
      <ul>
        <li><strong>읽기 전용 정적 데이터:</strong> 카테고리 목록, 설정값 등 → Server Component 최우선 대상</li>
        <li><strong>읽기 중심 동적 데이터:</strong> 콘텐츠 목록, 사용자 프로필 → Server Component 적합</li>
        <li><strong>상호작용 의존 데이터:</strong> 검색 결과, 필터 상태에 따른 목록 → Client Component 유지</li>
        <li><strong>실시간 데이터:</strong> WebSocket, polling 기반 → Client Component 유지</li>
      </ul>

      <p>이 분류 작업만 해도 전체 앱의 약 40%는 서버에서 처리할 수 있다는 사실을 확인했습니다.</p>

      <h2>마이그레이션 순서: 가장 단순한 것부터</h2>

      <h3>1단계: 정적 레이아웃 컴포넌트</h3>
      <p>사이드바, 헤더, 푸터처럼 데이터 패칭 없이 순수하게 레이아웃만 담당하는 컴포넌트부터 시작합니다. 이미 Server Component나 다름없는 구조이기 때문에 변환 과정에서 버그가 생길 가능성이 거의 없습니다.</p>

      <pre><code>// Before: 불필요하게 'use client'가 붙어 있는 경우
'use client';
export function Sidebar({ items }: { items: NavItem[] }) {
  return (
    &lt;nav&gt;
      {items.map(item =&gt; &lt;NavLink key={item.id} {...item} /&gt;)}
    &lt;/nav&gt;
  );
}

// After: 'use client' 제거, Server Component로 전환
export function Sidebar({ items }: { items: NavItem[] }) {
  return (
    &lt;nav&gt;
      {items.map(item =&gt; &lt;NavLink key={item.id} {...item} /&gt;)}
    &lt;/nav&gt;
  );
}</code></pre>

      <h3>2단계: 데이터 패칭을 서버로 이동</h3>
      <p>클라이언트에서 <code>useEffect + fetch</code>로 데이터를 가져오던 컴포넌트를 Server Component로 변환합니다. 이 과정에서 가장 중요한 것은 캐시 정책을 명시하는 것입니다.</p>

      <pre><code>// Before: Client Component with useEffect
'use client';
function ProductList() {
  const [products, setProducts] = useState([]);
  useEffect(() =&gt; {
    fetch('/api/products').then(r =&gt; r.json()).then(setProducts);
  }, []);
  return &lt;ul&gt;{products.map(p =&gt; &lt;ProductItem key={p.id} {...p} /&gt;)}&lt;/ul&gt;;
}

// After: Server Component
async function ProductList() {
  const products = await fetch('https://api.example.com/products', {
    next: { revalidate: 60 }, // 60초마다 재검증
  }).then(r =&gt; r.json());
  return &lt;ul&gt;{products.map(p =&gt; &lt;ProductItem key={p.id} {...p} /&gt;)}&lt;/ul&gt;;
}</code></pre>

      <h3>3단계: Client boundary 최소화</h3>
      <p>상호작용이 필요한 부분만 <code>'use client'</code>로 격리합니다. 흔한 실수는 버튼 하나 때문에 부모 컴포넌트 전체를 Client로 만드는 것입니다.</p>

      <pre><code>// Bad: 전체가 Client Component가 됨
'use client';
async function ProductDetail({ id }) {
  // async 함수지만 Client Component라 DB 직접 호출 불가
  ...
}

// Good: 상호작용 부분만 분리
// ProductDetail.tsx (Server Component)
async function ProductDetail({ id }: { id: string }) {
  const product = await db.products.findUnique({ where: { id } });
  return (
    &lt;div&gt;
      &lt;h1&gt;{product.name}&lt;/h1&gt;
      &lt;AddToCartButton id={id} /&gt;  {/* Client Component만 분리 */}
    &lt;/div&gt;
  );
}

// AddToCartButton.tsx (Client Component)
'use client';
function AddToCartButton({ id }: { id: string }) {
  return &lt;button onClick={() =&gt; addToCart(id)}&gt;장바구니 추가&lt;/button&gt;;
}</code></pre>

      <h2>캐시 정책 설계가 핵심</h2>
      <p>Server Components에서 가장 많은 문제가 생기는 부분이 캐시입니다. Next.js App Router의 캐시 레이어는 여러 단계가 있으며, 각 단계를 이해하지 못하면 stale 데이터 문제가 반복됩니다.</p>

      <pre><code>// 캐시 정책 선택 기준

// 1. 캐시하지 않음 (항상 최신 데이터, 사용자별 데이터)
fetch(url, { cache: 'no-store' });

// 2. 시간 기반 재검증 (자주 바뀌지 않는 공용 데이터)
fetch(url, { next: { revalidate: 300 } }); // 5분

// 3. 태그 기반 재검증 (데이터 변경 이벤트에 연동)
fetch(url, { next: { tags: ['products'] } });

// 상품 수정 후 태그 무효화 (Server Action에서)
import { revalidateTag } from 'next/cache';
export async function updateProduct(id: string, data: ProductData) {
  await db.products.update({ where: { id }, data });
  revalidateTag('products'); // 관련 캐시 즉시 무효화
}</code></pre>

      <div class="warn">사용자별 데이터(장바구니, 프로필, 권한)는 반드시 <code>cache: 'no-store'</code>를 사용해야 합니다. 캐시 키에 사용자 식별자가 없으면 사용자 A의 데이터가 사용자 B에게 노출되는 심각한 보안 문제가 발생합니다.</div>

      <h2>전역 상태 라이브러리 역할 변화</h2>
      <p>레거시 SPA에서는 전역 상태(Redux, Zustand 등)가 데이터 패칭 캐시 역할을 겸했습니다. Server Components로 전환하면 서버 측 캐시가 그 역할을 대체하기 때문에, 전역 상태의 역할이 순수하게 UI 상태(모달 열림 여부, 선택 탭 등)로 좁혀집니다.</p>

      <p>데이터 패칭 관련 코드를 Server Component로 이전하면 자연스럽게 전역 상태의 복잡도가 줄어듭니다. 마이그레이션 후 전역 상태 관리 코드가 약 40% 감소했습니다.</p>

      <h2>성능 측정: 세 지표를 분리해서 보기</h2>
      <p>마이그레이션 전후 효과를 측정할 때 단순히 Lighthouse 점수만 보면 안 됩니다. 다음 세 지표를 분리해서 확인해야 합니다:</p>
      <ul>
        <li><strong>TTFB:</strong> 서버 렌더링 속도와 캐시 효율을 반영합니다. Server Component 전환 후 가장 먼저 개선되는 지표입니다.</li>
        <li><strong>LCP:</strong> 핵심 콘텐츠 렌더링 속도. 데이터 패칭 횟수 감소 효과가 나타납니다.</li>
        <li><strong>Hydration 비용:</strong> 클라이언트 JS 실행 시간. 번들 감소 효과가 직접 나타납니다.</li>
      </ul>

      <p>팀에서는 각 릴리즈마다 동일 시나리오를 벤치마크해 전환 전후 차이를 추적했습니다. 6개월 결과:</p>
      <ul>
        <li>클라이언트 JS 번들 크기: 약 35% 감소</li>
        <li>LCP (p75): 2.8초 → 1.4초</li>
        <li>초기 데이터 패칭 횟수: 평균 4.2회 → 1.8회</li>
      </ul>

      <h2>마무리</h2>
      <p>결론은 점진 도입입니다. 가장 단순한 컴포넌트에서 성공 패턴을 만들고, 그 패턴을 확장하는 방식이 장기적으로 안정적입니다. 전면 전환 시도는 중간에 롤백해야 하는 상황을 만들기 쉽습니다.</p>

      <p>마이그레이션 과정에서 발견한 추가 이점은, 데이터 패칭 책임이 서버 컴포넌트로 집중되면서 클라이언트 컴포넌트의 역할이 명확해지고 테스트하기 쉬워진다는 점이었습니다. 성능 개선과 구조 개선이 함께 일어나는 드문 케이스였습니다.</p>

      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
