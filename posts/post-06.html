<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="WSL2와 네이티브 Linux 개발 환경을 파일 I/O, 빌드 속도, Docker 성능 기준으로 비교하고 실무 선택 기준을 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-06.html">
  <title>WSL2 vs 네이티브 Linux: 개발 환경 성능 비교와 선택 기준 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    table { width: 100%; border-collapse: collapse; margin: 0 0 20px; font-size: 0.93rem; }
    th { background: #f0ede4; text-align: left; padding: 10px 12px; border: 1px solid var(--border); }
    td { padding: 9px 12px; border: 1px solid var(--border); }
    tr:nth-child(even) td { background: #faf9f6; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>WSL2 vs 네이티브 Linux: 개발 환경 성능 벤치마크와 선택 기준</h1>
      <p class="meta">게시일: 2026년 1월 8일 · 14분 읽기</p>

      <p>Windows에서 Linux 개발 환경을 구성할 때 가장 먼저 부딪히는 질문이 "WSL2로 충분한가, 아니면 네이티브 Linux로 가야 하는가"입니다. 단순히 취향의 문제가 아닙니다. 어떤 워크로드를 주로 다루느냐에 따라 성능 차이가 체감될 만큼 달라집니다.</p>

      <p>이 글은 Node.js 빌드, Rust 컴파일, Docker 이미지 빌드, 대용량 파일 watch 네 가지 시나리오를 기준으로 두 환경을 비교한 결과와, 그 위에서 도출한 실무 권장 구성을 공유합니다.</p>

      <h2>WSL2 구조 이해하기</h2>
      <p>WSL2는 경량 Hyper-V VM 위에서 실제 Linux 커널을 실행합니다. WSL1처럼 시스템 콜을 번역하는 방식이 아니라, 진짜 커널이 돌아가기 때문에 대부분의 Linux 바이너리와 시스템 콜이 그대로 동작합니다.</p>

      <p>핵심 이슈는 파일시스템 경계입니다. WSL2에는 두 가지 파일시스템이 공존합니다:</p>
      <ul>
        <li><strong>WSL ext4 파티션:</strong> <code>/home/user/</code> 경로. Linux 네이티브 파일시스템으로 I/O 성능이 빠릅니다.</li>
        <li><strong>Windows NTFS 마운트:</strong> <code>/mnt/c/</code> 경로. Plan 9 파일시스템 프로토콜을 통해 접근하며, 소규모 파일 다수 접근 시 성능이 크게 저하됩니다.</li>
      </ul>

      <div class="note">소스 코드를 <code>/mnt/c/Users/...</code> 같은 Windows 드라이브에 두고 WSL2로 빌드하면 속도가 극도로 느려집니다. 이것이 WSL2가 느리다는 인식의 주요 원인입니다. WSL ext4 파티션에 소스를 두면 결과가 완전히 달라집니다.</div>

      <h2>테스트 환경 및 시나리오</h2>
      <p>동일 하드웨어(AMD Ryzen 9, NVMe SSD, 32GB RAM)에서 다음 세 환경을 비교했습니다:</p>
      <ul>
        <li><strong>A:</strong> WSL2 + 소스를 ext4에 저장</li>
        <li><strong>B:</strong> WSL2 + 소스를 /mnt/c (Windows NTFS)에 저장</li>
        <li><strong>C:</strong> 네이티브 Ubuntu 22.04 (듀얼 부트)</li>
      </ul>

      <h3>Node.js 프로젝트 빌드 (npm run build)</h3>
      <table>
        <tr><th>환경</th><th>콜드 빌드</th><th>증분 빌드</th></tr>
        <tr><td>A (WSL2 ext4)</td><td>18.2초</td><td>4.1초</td></tr>
        <tr><td>B (WSL2 /mnt/c)</td><td>87.4초</td><td>31.6초</td></tr>
        <tr><td>C (네이티브)</td><td>16.9초</td><td>3.8초</td></tr>
      </table>

      <h3>Rust 프로젝트 컴파일 (cargo build --release)</h3>
      <table>
        <tr><th>환경</th><th>풀 빌드</th><th>증분 빌드</th></tr>
        <tr><td>A (WSL2 ext4)</td><td>2분 14초</td><td>12초</td></tr>
        <tr><td>B (WSL2 /mnt/c)</td><td>8분 03초</td><td>1분 49초</td></tr>
        <tr><td>C (네이티브)</td><td>2분 07초</td><td>11초</td></tr>
      </table>

      <p>WSL2 ext4와 네이티브 Linux의 성능 차이는 5~10% 수준으로, 대부분의 개발 워크로드에서 무시할 수 있는 수준입니다. 반면 Windows NTFS 마운트를 사용하면 3~5배 이상 느려집니다.</p>

      <h2>Docker 성능 비교</h2>
      <p>Docker Desktop on Windows는 WSL2 백엔드를 사용합니다. 컨테이너 자체 실행 성능은 네이티브 Linux와 비슷하지만, 빌드 컨텍스트 전달 방식에 따라 차이가 생깁니다.</p>

      <pre><code># Docker 이미지 빌드 (Node 앱 기준)

# WSL2 ext4에서 context 전달
time docker build -t myapp .
# A: 1분 32초
# C: 1분 28초 (차이 미미)

# /mnt/c에서 context 전달
time docker build -t myapp .
# B: 6분 51초 (context 전송 오버헤드가 큼)</code></pre>

      <p>bind mount로 Windows 경로를 사용하면 개발 중 핫리로드가 느린 문제가 생깁니다. Vite dev server나 nodemon이 느리다면 대부분 이 문제입니다. 소스를 ext4로 이동하는 것만으로 해결됩니다.</p>

      <h2>WSL2 권장 설정 (.wslconfig)</h2>
      <p>WSL2를 제대로 쓰려면 메모리와 CPU 제한을 명시해야 합니다. 기본값으로 두면 WSL2가 물리 메모리의 절반까지 사용해 Windows 측 성능이 저하될 수 있습니다.</p>

      <pre><code># C:\Users\사용자명\.wslconfig
[wsl2]
memory=16GB        # 물리 메모리의 50% 이하로 설정
processors=8       # 논리 코어 수의 절반 권장
swap=8GB
localhostForwarding=true

[experimental]
autoMemoryReclaim=gradual  # 메모리 자동 반환 활성화</code></pre>

      <p>WSL2 내부 설정도 별도 최적화가 필요합니다:</p>

      <pre><code># /etc/wsl.conf (WSL2 내부에서 편집)
[automount]
options = "metadata,uid=1000,gid=1000,umask=22,fmask=11"

[interop]
enabled = true
appendWindowsPath = false  # Windows PATH를 Linux에 추가하지 않음 (명령어 충돌 방지)</code></pre>

      <h2>파일 watch 안정화</h2>
      <p>파일 변경 감지는 WSL2에서 특히 주의해야 할 영역입니다. 파일이 많은 프로젝트에서 inotify 한도를 초과하면 <code>ENOSPC: System limit for number of file watchers reached</code> 오류가 발생합니다.</p>

      <pre><code># inotify 한도 늘리기 (WSL2 내부, 영구 적용)
echo "fs.inotify.max_user_watches=524288" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# 현재 값 확인
cat /proc/sys/fs/inotify/max_user_watches</code></pre>

      <p>node_modules가 큰 프로젝트나 모노레포 환경에서는 이 설정이 필수입니다. Vite, Webpack, nodemon 모두 이 한도에 영향을 받습니다.</p>

      <h2>네이티브 Linux가 유리한 경우</h2>
      <p>WSL2가 많이 발전했지만, 아래 상황에서는 네이티브 Linux가 여전히 우위에 있습니다:</p>
      <ul>
        <li><strong>컨테이너 밀도가 높은 환경:</strong> kind, minikube 등 Kubernetes 로컬 클러스터를 여러 개 운영할 때</li>
        <li><strong>커널 모듈이 필요한 작업:</strong> eBPF, 커스텀 네트워크 드라이버 개발</li>
        <li><strong>GPU 집약적 작업:</strong> CUDA 직접 제어 (WSL2도 지원하지만 레이어 오버헤드 존재)</li>
        <li><strong>CI 환경과 완전한 일치가 필요한 경우:</strong> 환경 차이로 인한 CI 실패를 원천 차단하고 싶을 때</li>
      </ul>

      <h2>WSL2가 유리한 경우</h2>
      <ul>
        <li><strong>Windows 도구와 혼용:</strong> Office, 기업 보안 프로그램, Windows 전용 IDE 등이 필수인 환경</li>
        <li><strong>빠른 컨텍스트 전환:</strong> Windows와 Linux 작업을 자주 오가야 할 때</li>
        <li><strong>조직 표준 환경:</strong> 회사 장비가 Windows 전용일 때</li>
        <li><strong>온보딩 속도:</strong> 팀원이 Linux에 익숙하지 않을 때 진입 장벽이 낮음</li>
      </ul>

      <h2>실무 권장 구성 정리</h2>
      <p>대부분의 개인 개발자와 소규모 팀에는 <strong>WSL2 + ext4 저장소</strong> 조합을 권장합니다. Windows의 생산성 도구를 유지하면서도 Linux 개발 환경의 이점을 거의 동일하게 누릴 수 있습니다.</p>

      <p>반드시 지켜야 할 원칙:</p>
      <ol>
        <li>소스 코드는 반드시 WSL2 ext4 파티션(<code>~/projects/</code>)에 저장</li>
        <li><code>.wslconfig</code>로 메모리/CPU 상한 명시</li>
        <li>inotify 한도 증가 설정</li>
        <li>Docker Desktop은 WSL2 백엔드 활성화 확인</li>
        <li>CI는 Linux 네이티브 환경 유지 (devcontainer 사용 권장)</li>
      </ol>

      <p>WSL2가 느리다는 인식은 대부분 설정 문제에서 비롯됩니다. 위 설정을 적용하면 네이티브 Linux와 체감 차이가 거의 없는 환경을 만들 수 있습니다.</p>

      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
