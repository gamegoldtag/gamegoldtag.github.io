<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="프론트엔드 번들 크기를 줄이고 초기 렌더 성능을 실제로 개선하는 실전 최적화 전략을 코드와 함께 정리했습니다.">
  <meta name="robots" content="index, follow">
  <link rel="canonical" href="https://ikakao.kr/posts/post-08.html">
  <title>프론트엔드 번들 최적화 실전 가이드 | DevInsight</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable.min.css">
  <style>
    :root { --font: "Pretendard Variable", "Pretendard", sans-serif; --ink: #1a1a2e; --muted: #6b6b7b; --bg: #f8f6f1; --card: #fff; --border: #d4d0c8; --accent: #c0392b; }
    body { margin: 0; font-family: var(--font); background: var(--bg); color: var(--ink); line-height: 1.85; }
    .wrap { max-width: 800px; margin: 0 auto; padding: 48px 20px 80px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 34px; }
    h1 { margin: 0 0 10px; font-size: 2rem; line-height: 1.35; }
    h2 { margin: 36px 0 12px; font-size: 1.25rem; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    h3 { margin: 20px 0 8px; font-size: 1.05rem; color: var(--accent); }
    p { margin: 0 0 16px; }
    ul, ol { margin: 0 0 16px 20px; }
    li { margin-bottom: 8px; }
    pre { background: #2d2d3f; color: #e6e6e6; border-radius: 10px; padding: 14px 16px; overflow-x: auto; font-size: 0.88rem; margin: 0 0 16px; }
    code { background: #eee; padding: 1px 5px; border-radius: 4px; font-size: 0.88em; }
    pre code { background: none; padding: 0; }
    .meta { color: var(--muted); font-size: 0.92rem; margin-bottom: 24px; }
    .note { background: #f3efe6; border: 1px solid var(--border); border-radius: 10px; padding: 12px 16px; margin: 16px 0; font-size: 0.95rem; }
    .back { display: inline-block; margin-top: 28px; color: var(--accent); text-decoration: none; font-weight: 700; }
  </style>
</head>
<body>
  <main class="wrap">
    <article class="card">
      <h1>프론트엔드 번들 최적화: 체감 성능으로 연결되는 실전 체크리스트</h1>
      <p class="meta">게시일: 2025년 12월 24일 · 15분 읽기</p>

      <p>번들 최적화를 처음 시작하는 팀은 흔히 "번들 크기를 줄이면 빠르다"는 단순한 도식으로 접근합니다. 틀리지 않지만, 충분하지도 않습니다. 실제로 사용자가 체감하는 속도는 번들 총량이 아니라 <strong>초기 렌더에 필요한 자원이 얼마나 빠르게 전달되는가</strong>에 달려 있습니다. 번들 크기를 40% 줄여도 LCP가 개선되지 않는 경우를 여러 번 목격했습니다. 원인은 항상 실행 시점 제어 실패였습니다.</p>

      <p>이 글은 실무에서 직접 적용하며 검증한 번들 최적화 전략을 단계별로 정리합니다. 도구 사용법보다 <strong>어떤 순서로, 왜 이 결정을 해야 하는가</strong>에 집중합니다.</p>

      <h2>1단계: 번들 현황 파악부터 시작하기</h2>
      <p>최적화는 측정 없이 시작하면 안 됩니다. 우선 현재 번들 구성을 시각화해야 합니다. Webpack을 사용한다면 <code>webpack-bundle-analyzer</code>, Vite라면 <code>rollup-plugin-visualizer</code>가 표준 도구입니다.</p>

      <pre><code># Vite 프로젝트
npm install --save-dev rollup-plugin-visualizer

# vite.config.ts
import { visualizer } from 'rollup-plugin-visualizer';

export default {
  plugins: [
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ],
};</code></pre>

      <p>빌드 후 생성되는 트리맵에서 확인해야 할 항목은 세 가지입니다:</p>
      <ul>
        <li><strong>예상보다 큰 라이브러리:</strong> moment.js, lodash 전체, 날짜 라이브러리 중복 포함 등</li>
        <li><strong>중복 번들:</strong> 동일 패키지가 버전 차이로 두 번 포함된 경우</li>
        <li><strong>초기 로드에 불필요한 모듈:</strong> 사용자가 처음 접하지 않는 기능인데 main chunk에 포함된 경우</li>
      </ul>

      <h2>2단계: 코드 스플리팅 - 경로 단위부터</h2>
      <p>코드 스플리팅의 첫 번째 대상은 라우트입니다. React Router나 Next.js를 사용한다면 페이지 단위 lazy loading이 가장 빠른 성과를 냅니다. 설정 변경만으로 초기 번들에서 대부분의 페이지 코드를 분리할 수 있습니다.</p>

      <pre><code>// Before: 모든 페이지가 초기 번들에 포함
import DashboardPage from './pages/Dashboard';
import SettingsPage from './pages/Settings';
import ReportPage from './pages/Report';

// After: 필요한 시점에만 로드
const DashboardPage = React.lazy(() => import('./pages/Dashboard'));
const SettingsPage = React.lazy(() => import('./pages/Settings'));
const ReportPage = React.lazy(() => import('./pages/Report'));

// Suspense로 로딩 상태 처리
&lt;Suspense fallback={&lt;PageSkeleton /&gt;}&gt;
  &lt;Routes&gt;
    &lt;Route path="/dashboard" element={&lt;DashboardPage /&gt;} /&gt;
    &lt;Route path="/settings" element={&lt;SettingsPage /&gt;} /&gt;
  &lt;/Routes&gt;
&lt;/Suspense&gt;</code></pre>

      <p>라우트 스플리팅만으로도 초기 JS 번들이 30~50% 줄어드는 경우가 많습니다. 단, 페이지 이동 시 코드를 내려받는 지연이 생기므로, 사용자가 다음에 이동할 가능성이 높은 페이지는 preload로 미리 준비해두는 것이 좋습니다.</p>

      <pre><code>// 마우스 hover 시 prefetch 트리거
const prefetchSettings = () => import('./pages/Settings');

&lt;Link to="/settings" onMouseEnter={prefetchSettings}&gt;설정&lt;/Link&gt;</code></pre>

      <h2>3단계: 무거운 라이브러리 교체 또는 부분 import</h2>
      <p>번들 크기에서 가장 큰 비중을 차지하는 원인 중 하나는 라이브러리 전체 import입니다. 몇 가지 대표 사례를 정리합니다.</p>

      <h3>lodash 부분 import</h3>
      <pre><code>// Bad: lodash 전체 (70KB+)
import _ from 'lodash';
_.debounce(fn, 300);

// Good: 필요한 함수만
import debounce from 'lodash/debounce';
debounce(fn, 300);</code></pre>

      <h3>moment.js → dayjs로 교체</h3>
      <pre><code>// moment.js: 67KB (gzip 기준)
import moment from 'moment';
moment().format('YYYY-MM-DD');

// dayjs: 2KB (gzip 기준), API 호환성 높음
import dayjs from 'dayjs';
dayjs().format('YYYY-MM-DD');</code></pre>

      <h3>chart.js 부분 등록</h3>
      <pre><code>// Bad: 모든 차트 타입 포함
import Chart from 'chart.js/auto';

// Good: 사용하는 타입만 등록
import {
  Chart, LineController, LineElement,
  PointElement, LinearScale, Title
} from 'chart.js';
Chart.register(LineController, LineElement, PointElement, LinearScale, Title);</code></pre>

      <p>이 패턴은 chart.js 외에 echarts, d3, three.js 같은 시각화 라이브러리에도 동일하게 적용됩니다. 사용하지 않는 기능을 포함시키지 않는 것이 핵심입니다.</p>

      <h2>4단계: 이미지 최적화</h2>
      <p>JavaScript 번들만 신경 쓰다가 이미지를 놓치는 경우가 많습니다. 실제로 이미지가 JS보다 전체 바이트에서 훨씬 큰 비중을 차지하는 페이지가 많습니다. 이미지는 단순 크기 최적화 외에도 포맷과 로딩 시점 제어가 중요합니다.</p>

      <ul>
        <li><strong>WebP/AVIF 포맷 전환:</strong> 동일 품질 대비 JPEG 대비 30~50% 용량 절감</li>
        <li><strong>lazy loading:</strong> <code>loading="lazy"</code> 속성으로 뷰포트 밖 이미지 지연 로드</li>
        <li><strong>srcset으로 반응형 이미지:</strong> 기기 해상도에 맞는 이미지만 전송</li>
        <li><strong>LCP 이미지는 preload:</strong> 첫 화면에 보이는 핵심 이미지는 반드시 preload 처리</li>
        <li><strong>width/height 명시:</strong> CLS(누적 레이아웃 이동) 방지를 위해 치수 속성 필수</li>
      </ul>

      <pre><code>&lt;!-- LCP 이미지 preload (head에 배치) --&gt;
&lt;link rel="preload" as="image" href="/hero.webp" fetchpriority="high" /&gt;

&lt;!-- 일반 이미지 lazy loading --&gt;
&lt;img
  src="/product.webp"
  loading="lazy"
  decoding="async"
  width="400" height="300"
  alt="상품 이미지"
/&gt;</code></pre>

      <h2>5단계: 번들 예산(Bundle Budget) 자동화</h2>
      <p>최적화는 한 번 하고 끝나는 작업이 아닙니다. 새 기능을 추가하거나 의존성을 업데이트하면서 번들이 조용히 커지는 현상을 "번들 비대화(Bundle Bloat)"라고 부릅니다. 이를 방지하려면 CI/CD 파이프라인에 번들 예산 검증을 넣어 자동으로 감지하도록 해야 합니다.</p>

      <pre><code># .github/workflows/bundle-check.yml
name: Bundle Size Check
on: [push, pull_request]

jobs:
  bundle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run build
      - name: Check bundle size
        run: node scripts/check-bundle-size.js</code></pre>

      <pre><code>// scripts/check-bundle-size.js
const fs = require('fs');
const path = require('path');

const BUDGET_BYTES = {
  'index':  150 * 1024,  // 메인 청크 150KB
  'vendor': 300 * 1024,  // 벤더 청크 300KB
};

const distDir = path.join(__dirname, '../dist/assets');
let failed = false;

fs.readdirSync(distDir).forEach(file => {
  if (!file.endsWith('.js')) return;
  const size = fs.statSync(path.join(distDir, file)).size;
  const key = Object.keys(BUDGET_BYTES).find(k => file.includes(k));
  if (key && size > BUDGET_BYTES[key]) {
    const kb = (size / 1024).toFixed(1);
    const budget = BUDGET_BYTES[key] / 1024;
    console.error(`❌ ${file}: ${kb}KB (예산 ${budget}KB 초과)`);
    failed = true;
  }
});

if (failed) process.exit(1);
console.log('✅ 번들 예산 통과');</code></pre>

      <div class="note">번들 예산은 팀 규모와 서비스 특성에 따라 다릅니다. 중요한 것은 "예산이 얼마냐"가 아니라 "예산이 있고 자동 검증된다"는 사실입니다. 회귀는 배포 초기보다 3~4개월 뒤에 주로 발생합니다.</div>

      <h2>6단계: RUM 기반으로 최적화 효과 확인하기</h2>
      <p>Lighthouse 점수는 실험실 환경 수치입니다. 실제 사용자 경험과 괴리가 생길 수 있습니다. 최적화 전후 효과는 반드시 RUM(Real User Monitoring) 데이터로 확인해야 합니다.</p>

      <pre><code>import { onCLS, onLCP, onINP, onTTFB } from 'web-vitals';

function sendToAnalytics({ name, value, id }) {
  gtag('event', name, {
    value: Math.round(name === 'CLS' ? value * 1000 : value),
    metric_id: id,
  });
}

onCLS(sendToAnalytics);
onLCP(sendToAnalytics);
onINP(sendToAnalytics);
onTTFB(sendToAnalytics);</code></pre>

      <p>개선 작업 후 RUM 지표가 실제로 나아졌는지 최소 1~2주 데이터를 비교하는 습관을 들이면, 불필요한 최적화에 시간을 낭비하는 일을 막을 수 있습니다. hit ratio가 높아도 실제 사용자 LCP가 나쁘면 의미 없는 최적화입니다.</p>

      <h2>자주 놓치는 항목들</h2>
      <ul>
        <li><strong>폰트 최적화:</strong> <code>font-display: swap</code>, woff2 포맷, 서브셋 처리. 커스텀 폰트는 생각보다 큰 LCP 영향을 줍니다.</li>
        <li><strong>서드파티 스크립트 defer/async:</strong> 광고, 분석 스크립트가 파싱을 블록하는 경우가 많습니다.</li>
        <li><strong>CSS 미사용 규칙 제거:</strong> Tailwind라면 purge 설정이 제대로 됐는지 확인하세요.</li>
        <li><strong>source map 프로덕션 포함 여부:</strong> source map이 프로덕션 빌드에 포함되면 불필요한 네트워크 요청이 발생합니다.</li>
        <li><strong>JSON 데이터 크기:</strong> API 응답에서 불필요한 필드가 대량 포함되면 파싱 비용이 늘어납니다.</li>
      </ul>

      <h2>마무리: 순서가 성과를 결정한다</h2>
      <p>번들 최적화는 해야 할 일의 목록이 아니라 우선순위 결정입니다. 제가 실무에서 정착한 순서는 다음과 같습니다:</p>
      <ol>
        <li>번들 시각화로 현황 파악</li>
        <li>라우트 단위 코드 스플리팅</li>
        <li>무거운 라이브러리 교체 또는 부분 import</li>
        <li>이미지/폰트 최적화</li>
        <li>번들 예산 자동 검증 CI 구성</li>
        <li>RUM 기반 효과 측정</li>
      </ol>
      <p>이 순서대로 적용하면 각 단계의 성과가 측정 가능하고, 팀에 공유하기도 쉽습니다. 번들 숫자를 줄이는 것이 목표가 아니라, 사용자가 콘텐츠를 더 빠르게 보게 하는 것이 목표라는 점을 항상 기억해야 합니다.</p>

      <a class="back" href="/">홈으로 돌아가기</a>
    </article>
  </main>
</body>
</html>
